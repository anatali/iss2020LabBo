<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
    <!--
<link rel="stylesheet" type="text/css" href="../css/issStyle1.css">
<script type="text/javascript" src="../css/issStyle.js"></script>
-->
<style type="text/css">
body
{
    margin-left:  30px;
    margin-right: 30px;
};

P
{
    font-family: Tahoma;
    font-size: 10pt;
};

a, a:visited, a:active, a:link, a:hover {
    text-decoration: underline;
    color: #545454;
    background-color: transparent;
}

a:hover {
    background-color: #cccccc;
}


hr {
    clear: both;
    height: 1px;
    color: #242424;
    background-color: transparent;
}

h1, h2, h3 {
    color: #242424;
    clear: left;
    font: 100% Tahoma, Helvetica, Arial, sans-serif;
    margin: 10;
    margin-right: 15px;
    margin-bottom: 0.5em;
    padding-top: 0.5em;
    border-bottom: 1px solid #242424;
}

h1 {
    font-size: 150%;
    background-color: #b2c0ff;
}

h2 {
    background-color: #d9fbff;
    font-size: 110%;
}

h3 {
	background-color: #e6ccff;
    font-size: 80%;
}
h4 {
    background-color: #99ffcc;
    font-size: 100%;
	width: 750px;
}
#i {
    color: #ff1010;
}
tt{
	font-family: "Arial";
    font-size: 80%;
	color: #006600;
}
em{
	font-family: "Arial";
    font-size: 80%;
	font-weight: bold;
	border-style:solid;
	border-color: #ccffff;
    color: #0033cc;
}
bc{
	font-family: "Arial";
	font-size: 80%;
	font-weight: bold;
    color: #990000;
	background-color: #fcf8c7;
}
k{
	font-family: "Arial";
	font-weight: bold;
    color: #990000;
	 
}
ks{
	font-family: "Arial";
	font-weight: bold;
    color: #0000CD	;
	 
}
kc{
	font-family: "Arial";
	font-weight: bold;
    color: #008000	;
	 
}
pre{
	font-family: "Helvetica";
	font-size: 70%;
	background-color: #fcf8c7; 
}
 
m{
	font-family: "Helvetica";
	line-height: 100%;
 	font-size: 75%;
}
div.body{
	width: 800px;
    font-size: 18px;
}    
div.req{
	background-color: #d9ffb3;
    font-size: 18px;
	width: 700px;
    border: 3px solid green;
    padding: 15px;
    margin: 10px;
}    

div.remark{
	background-color: #FFFC33;     
    border: 3px solid green;
    padding: 15px;
    margin: 10px;
}  

table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}
</style>
    
<head>
   
<title>LABKotlinIntroISS</title></head>
    
<body>

<div class="body"> 


<div id="top">
<h1>LabKotlin | Introduction to <a href="https://kotlinlang.org/" target="web">KOTLIN</a></h1> 

<a href="http://htmlpreview.github.com/?https://github.com/anatali/iss2020LabBo/blob/master/it.unibo.issLabStart/userDocs/LectureBologna1920.html" 
target="isslm">LabISS-lectures site</a> 
</div> 
<h2><a id="basics"/>OVERVIEW</h2>

<ol>
<li>Basic elements of any computation are data and <bc>functions</bc> (data can be also viewed as functions that return values). </li>
<li>Functions are <bc>first class objects</bc> that have a type, can be assigned to variables and used as function arguments or as
return values.</li>
<li>Computations almost always require the usage of <bc>threads</bc> and to face concurrency problems, even in <tt>multi-core</tt> environments.</li>
<li><bc>Lexical Closures</bc> are often used as callbacks in <bc>asynchronous</bc> (IO-bound) programming according to a Continuation Passing Style (<bc>CPS</bc>)</li>
<li>The single-threaded <tt>event-loop model</tt> of <ks>Node.js</ks> (JavaScript) leads to the idea of message/job queue.</li>
<li>On May 2019, Google announced that the 
<a href="https://en.wikipedia.org/wiki/Kotlin_(programming_language)" target="web">Kotlin programming language</a>
 is now its preferred language for Android app developers.
 <m>The Android OS is single threaded by default, which means operations will run by default on the UI thread except 
they are explicitly scheduled to run on a background thread. 
The UI thread is responsible for handling UI updates and executing long running operations on this thread can freeze your app, 
or crash the app and show an <ks>ANR</ks> (Application Not Responding) error.</m>
</li>
<li>The Kotlin concept of <bc>coroutine</bc> allows us to introduce thread in a very light way. The concept is based on the idea
of suspend a  computation without blocking a thread (<bc>suspend function</bc>) implemented using (under the hoods) a state machine 
and <tt>CPS</tt>. </li>
<li>Kotlin <bc>channels</bc> promote interaction among coroutines in term of <tt>stream of values</tt>.</li>
<li>Kotlin <bc>actors</bc> promote a <tt>message-based programming style</tt> that overcomes traditional procedure-call interaction without
loosing in performance.</li>
</ol>

 
 <table style="width:95%">
<tbody>	
<tr>
<td style="width:55%">
<h3 id="index">INDEX</h3>

<ol>
<li><a href="#data">Data, Types and Variables</a></li>
<li><a href="#funs">Functions</a></li>
<li><a href="#lambda">Using lambda</a></li>
<li><a href="#clos">Closures, Callbacks and CPS</a></li>
<li><a href="#async">Towards Asynchronous Programming</a></li>
<li><a href="#coroutinesIntro">Introduction to coroutines</a></li> 
<li><a href="#dispatchers">Dispatchers</a></li>  
<li><a href="#suspend">Suspending functions</a></li>
<!-- <li><a href="#concur">Concurrency</a></li> -->
<li><a href="#channels">Kotlin Channels</a></li>
<li><a href="#kotlinprodcons">Producers-consumers in Kotlin</a></li>
<li><a href="#actors">Kotlin Actors</a></li>
<li><a href="#sequences">Sequences (suspendable)</a></li>
<li><a href="#classes">Classes and Objects in Kotlin</a>
	<ul>
	<li><a href="#kotlinObject">Kotlin object</a> </li>
	<li><a href="#kotlinclass">Kotlin class</a></li>
	<li><a href="#propdeleg">Property delegation</a></li>
	<li><a href="#dataclass">data class</a></li>
	<li><a href="#companionobj">companion object</a></li>
	<li><a href="#enumclass">enum class</a></li>
	<li><a href="#ill">init, lateinit, lazy</a></li>
	<li><a href="#inheritance">Inheritance</a></li>
	<li><a href="#sealedclass">Sealed class</a></li>
	</ul>
</li> 

<br/><br/>
See <a href="https://kotlinlang.org/docs/kotlin-docs.pdf" target="web">Kotlin Language Documentation</a>
  
</ol>
</td>

<td style="width:45%">
<img src="./img/KotlinInAction.png" alt="KotlinInAction" width="70%" height="40%">
 
</td>

</tr> 
</tbody>	
</table>
 
 
 
To run the <a href="https://kotlinlang.org/" target="web">KOTLIN</a> experiments, 
use an IDE or <a href="https://play.kotlinlang.org" target="web">Kotlin Playground</a>.

You can consult also: <a href="https://try.kotlinlang.org/#/Examples" target="web">Kotlin online</a>
<br/> <br/> 

For the examples hereunder, look at <a href="../src/kotlindemo/demoBasic.kt" target="code">demoBasic.kt</a>  (project <m><ks>it.unibo.kotlinIntro</ks></m>).

<h2><a id="data"/>Data, Types and Variables</h2>

<center><table style="width:95%">

<tbody>	
<tr>
<td style="width:45%"><pre> <k>val</k> base : Int = 0</pre> </td>
<td><m><em>Immutable reference</em>. </m> </td>
</tr>

<tr>
<td><pre><k>var</k> counter = 0</pre> </td>
<td><m><em>Mutable reference</em>. The Type <bc>Int</bc> is inferred</m> </td>
</tr>

<tr>
<td><pre>val name = "Bob"
val st   ="hello<k>$</k>name"
<kc>------</kc>
println( st )	//Hello Bob
</pre> </td>
<td><m><em>String template</em></m> </td>
</tr>


<tr>
<td><pre>val data : String<k>?</k> = null
val v = data<k>?</k>.length ?: 0
<kc>------</kc>
println("v=$v")	//0
</pre> </td>
<td><m><em>Nullable type</em> with safe null access</m> </td>
</tr>
<tr>
<td><pre>
val v01 : <k>Any</k> = 23
<kc>------</kc>
println( "v01 is String=${v01 </k>is</k> String}") //false
println( "v01 is Int=${v01 <k>is</k> Int}")	//true
</pre> </td>
<td><m><em>Type hierarchy</em>. <bc>Any</bc> is is a non-nullable type that denotes the root of the Kotlin class hierarchy. <br/>
<bc>Unit</bc> is used as a return type of a function that has nothing to return.<br/>
 <bc>is</bc> is a predefined check operator (like Java <bc>instanceOf</bc>)
</m> </td>
</tr>


<tr>
<td><pre>
val v02  : Any = "Bob"
val sv02 = v02 is String
val nv02 = v02 is Int
<kc>------</kc>
println( "v02 is String=${sv02}") //true
println( "v02 is Int=${nv02}")	//false
<k>if (v02 is String)</k> print(v02.length)
</pre> </td>
<td><m><em>Smart cast</em>.  The compiler tracks the is-checks (and explicit casts) for immutable values and inserts 
(safe) casts automatically when needed.</m> 
</td>
</tr>

<tr>
<td><pre>//val n = v02.length 		<kc>//ERROR</kc>
val n02 = (v02 <k>as</k> String).length
<kc>------</kc>
println( "$n02")              <kc> //3</kc>

println( "${v02 as Int}") <kc>//java.lang.ClassCastException</kc>

println( "${v02 <k>as?</k> Int}")  	<kc>//null</kc>
val t : Int = v02 as? Int <k>?:</k> 100
<kc>------</kc>
println( "$t") 				<kc>//100</kc>
</pre> </td>
<td><m><em>Explicit casting</em>.<br/>
 The <bc>as</bc> operator performs type casting. <br/><br/>
The <bc>as?</bc> operator performs safe type casting.<br/><br/>
The <bc>?:</bc> is the <em>Elvis operator</em> that provides default values instead of null.
</m> </td>
</tr>

<tr>
<td ><pre>
val s1 = "a"
var s2 = "a"
<kc>------</kc>
println( "s1 === s2 : ${s1 <k>===</k> s2} ") 	<kc>//true</kc>
println( "s1 == s2  : ${s1 <k>==</k> s2} ")	<kc>//true</kc>

s2 = "b"
<kc>------</kc>
println( "s1 === s2 : ${s1 === s2} ") 	<kc>//false</kc>
s2 = "a"
<kc>------</kc>
println( "s1 === s2 : ${s1 === s2} ")	<kc>//true</kc>

val fa = java.io.File("a")
val fb = java.io.File("a")
<kc>------</kc>
println( "fa === fb : ${fa === fb}")	<kc>//false</kc>
println( "fa == fb  : ${fa == fb}")		<kc>//true</kc>

</pre> </td>
<td><m><em>Referential equality</em> <bc>===</bc> <br/>
<em>Structural equality</em> <bc>==</bc> 
(translated into a call of the <bc>equals</bc> function of the class) </td>
</tr>

<tr>
<td><pre> 
val aToz = "a"<k>..</k>"z"
val q = "q"
<kc>------</kc>
println( "q in aToz=${q <k>in</k> aToz}")				<kc>//true</kc>
println( "1 in aToz=${<k>"""</k>1<k>"""</k> in aToz}") 	<kc>//false</kc>
</pre> </td>
<td><m><em>Range</em> created by the <bc>..</bc> operator.
The <bc>in</bc> infix operator performs a belong test. Triple quotes <bc>"""</bc> do not require escaping chars</m></td>
</tr>

<tr>
<td><pre>
var arr = <k>arrayOf</k>(1,2,3)
<kc>------</kc>
println( "arr size=${arr.size}")
println( "firstEl=${arr[0]}  lastEl=${arr[arr.size-1]}")
</pre> </td>
<td><m><em>Array</em>. They are a regular collection class. <bc>size</bc> is a 
<a href="https://kotlinlang.org/docs/reference/properties.html" target="code"><em>Property</em></a>
</m> </td>
</tr>


</tbody>	
</table></center>

<br/><br/> 	
 
<h3>Utility functions</h3>
For the examples hereunder, start from <a href="../src/kotlindemo/demoTemplate.kt" target="code">demoTemplate.kt</a>  (project <m><ks>it.unibo.kotlinIntro</ks></m>)
that introduces:

<pre>
val <k>cpus</k> = Runtime.getRuntime().availableProcessors();

fun <k>curThread()</k> : String { 
	return "thread=${Thread.currentThread().name} / nthreads=${Thread.activeCount()}" 
}

inline fun <k>measureTimeMillis</k>(block: () -> Unit): Long {
    val start = System.currentTimeMillis()
    block()
    return System.currentTimeMillis() - start
}
</pre>

<h2><a id="funs"/>Functions </h2>

These examples are reported in  <a href="../src/kotlindemo/demoFun.kt" target="code">demoFun.kt</a>  (project <m><ks>it.unibo.kotlinIntro</ks></m>).
<br/><br/>
 

<center><table style="width:95%">
<tbody>	
<tr>
<td style="width:45%"><pre>
fun <k>fsum(a:Int, b:Int) : Int</k> {
  return a+b
}
<kc>------</kc>
println( " ${<ks>fsum(3,6)</ks>} " ) 	<kc>//9</kc>
</pre> </td>
<td><m>A <em>Top-level function</em> that returns a value.<br/>

<center><img src="./img/fun0.png" alt="fun0.png" width="50%"/></center>
 
 </m>
 </td>
</tr>

<tr>
<td><pre>var fcounter = 0
fun <k>incCounter() : Unit</k>{ fcounter++ }
fun <k>decCounter()</k> { fcounter-- }
<kc>------</kc>
println( "pre=$fcounter  " ) 	<kc>//pre=0</kc>
<ks>incCounter()</ks>
println( "post=$fcounter " ) 	<kc>//post=1</kc>
</pre> </td>
<td><m>Top-level functions that <em>do not </em> return a value. The return type <bc>Unit</bc> can be omitted</m><br/>

<center><img src="./img/funUnit.png" alt="funUnit.png" width="40%"/></center>
</td>
</tr>

<tr>

<tr>
<td><pre>
fun fsquare<k>(v: Int) = v * v</k>
<kc>------</kc>
println(  <ks>fsquare(3)</ks>  ) 	<kc>//9</kc>
</pre> </td>
<td><m><em>One line function</em>. Braces can be omitted. Return type can be omitted (it is inferred)</m> </td>
</tr>
 
<td>

<pre>
val ftaction : <k>() -> Unit</k> 	   
	<kc>//function type (no args, returns nothing (Unit)</kc>

val ftsum : <k>( Int,  Int) -> Int </k> 
	<kc>//function type (two args, returns an Int)</kc>

val ftgreet: <k>(String )-> <ks>()->Unit</ks></k>
	<kc>//returns another function  </kc>
</td>
<td><m><h3>Function type</h3> is just a syntactic sugar for an interface, but the interface cannot be used explicitly.
We can  use it to type local variables, properties or arguments.
It is implemented in Java as a <bc>FunctionN</bc> interface.
<br/>
A  way to provide a value function is to use a <em>function literal</em>:

<ul>
<li><bc>Lambda expression</bc></li>
<li><bc>Anonymous function</bc></li>

</ul>
</m> </td>
</tr>

<tr>
<td><pre>
val <k>ftaction= {</k> println("hello") <k>}</k>  <kc>//lambda expression</kc>
<kc>------</kc>
<ks>ftaction()</ks> 		<kc>//hello</kc>

<k>ftsum = {</k>  x:Int, y:Int -> x+y <k>}</k>  <kc>//lambda expression</kc>
val fva = <ks> ftsum(1,2)</ks> 
<kc>------</kc>
println("fva=$fva")	      <kc>//fva=3</kc>

val <k>ftgreet = {</k>  m: String -> { println(m)}   <k>}</k>
<kc>------</kc>
<ks> ftgreet( "Hello World" )<k>()</k></ks>  	<kc>//Hello World</kc>

println( <ks> { println( "Welcome" ) }</ks>)	<kc>//() -> kotlin.Unit</kc>
println( <ks> { println( "Welcome" ) }<k>()</k>)</ks> <kc>//Welcome  kotlin.Unit</kc>


val <k>fel = {</k>  print( "Last exp val:" ); 100  <k>}</k>
<kc>------</kc>
println( "${ <ks>fel()</ks> }" )  <kc>//Last exp val=100</kc>
</td>
<td><h3>Lambda Expression literal</h3>
<m>it can be assigned to a variable, just like any other literal. <br/><br/>
A call returns (the value of the) <bc>last</bc> expression </m> </td>
</tr>

<tr>
<td>
<pre>
val faction: <k>()-> Unit</k> = <ks>fun()</ks> { println("Hello from faction") }
<kc>------</kc>
faction() 		<kc>//Hello from faction</kc>

val fsquare: <k>(Int)->Int</k>  = <ks>fun(x)</ks> = x * x
<kc>------</kc>
println("fsquare=${fsquare(3)}")	      <kc>//fsquare=9</kc>

val greet: <k>(String)->()->Unit</k> = 
		<ks>fun</ks>(m:String) = <ks>fun()</ks>{ println("Printing $m") }
<kc>------</kc>
println( greet )			<kc>//(kotlin.String) -> () -> kotlin.Unit</kc>
println( greet( "Hello World1" ) )	<kc>//() -> kotlin.Unit</kc>
greet<ks>( "Hello World" )</ks><k>( )</k> 	<kc>//Printing Hello World</kc>

------------------------------------------
fun fexec23( op: <k>(Int, Int) : Int</k> ) : Int  {  <k>return</k> op(2,3)  }

val v23 =  fexec23( <ks>fun(x:Int,y:Int):Int{return x+y}</ks> )
<kc>------</kc>
println("$v23")         					<kc>//5</kc>
println( fexec23( { x:Int, y:Int -> x*y } )	 )	<kc>//6</kc>
</pre> </td>
<td><h3>Anonymous function</h3>
<m>another way to write a block of code instead of a Lambda expression. Needs <bc>return</bc>
like any function </m> </td>
</tr>


</tbody>	
</table></center>


<h2><a id="lambda"/>Using lambda</h2>
Java 8 introduced lambda expressions along with functional interfaces..<br/> 
A <m><k>functional interface</k></m> 
(see <a href="http://tutorials.jenkov.com/java-functional-programming/functional-interfaces.html"  target="web">Tutorial on Java Functional Interfaces</a>)
is an interface with a single method. They are commonly referred to as <i>Single Abstract Method</i> or <m><k>SAM</k></m>.
<br/> 
A Java functional interface can be implemented by a Java <m><k>Lambda Expression</k></m>
(see <a href="http://tutorials.jenkov.com/java/lambda-expressions.html"  target="web">Tutorial on Java Lambda Expressions</a>).
<br/><br/>
The examples hereunder are reported in  <a href="../src/kotlindemo/demoLambda.kt" target="code">demoLambda.kt</a>  (project <m><ks>it.unibo.kotlinIntro</ks></m>).
<br/><br/>

<center><table style="width:95%">
<tbody>	


<tr>
<td><pre>
fun exec23( <k>op:(Int,Int) -> Int</k> ) : Int { return op(2,3) }

val sum = { x:Int, y:Int -> x+y }
val mul = { x:Int, y:Int -> x*y }

println("${ exec23(sum) }")	      <kc>//5</kc>
println("${ exec23(mul) }")	      <kc>//6</kc>

</td>
<td><h3>Higher order functions</h3>
<center><img src="./img/funArgFun.png" alt="funArgFun.png" width="40%"/></center>
 
<m> </m> </td>
</tr>



<tr>
<td><pre>
val v1 = exec23( { x:Int, y:Int -> x-y } ) <k>//1) no shortcut</k>
<kc>------</kc>
println("v1=$v1")	      <kc>//v1=-1</kc>

val v2 = exec23<k>()</k> { x:Int, y:Int -> x-y } <k>//2) lambda last arg</k>
<kc>------</kc>
println("v2=$v2")	      <kc>//v2=-1</kc>

val v3 = exec23{ x:Int, y:Int -> x-y } <k>//3) () can be removed</k>
<kc>------</kc>
println("v3=$v3")	      <kc>//v3=-1</kc>

val v4 = exec23{ x,y -> x-y } <k>//4) arg types inferred</k>
<kc>------</kc>
println("v4=$v4")	      <kc>//v4=-1</kc>
</td>
<td><h3>Lambda syntax shortcut</h3> </td>
</tr>

<tr>
<td><pre>
fun p2( op: ( Int ) -> Int ) : Int { return op(2) }

    println( p2( { <k>x:Int-> x*x }</k> ) )	<kc>//4</kc>
    println( p2<k>( )</k>  { x:Int-> x*x } )	<kc>//4</kc>
    println(  p2 { <k>x:Int-> x*x</k> }	)	<kc>//4</kc>
    println(  p2 { <k>x -> x*x</k> } )		<kc>//4</kc>
    println(  p2 { <k>it -> it*it</k> } )		<kc>//4</kc>
    println(  p2 { <k>it*it</k> } )			<kc>//4</kc>
    println( p2{ <k>it * it / 2</k> } )		<kc>//2</kc>
</pre> </td>
<td><h3>Simplification in lambda call</h3>

<pre>
p2 { it*it }
</pre>

<m> The keyword <bc>it</bc> is an auto-generated parameter name </m></td>
</tr>



<td><pre>
fun modulo(k:Int): <k>(Int) -> Int</k>   <kc> //SIGNATURE</kc>
            = { it % k  }               <kc>//BODY</kc>	
<kc>------</kc>
println(  <ks>modulo(3)<k>(5)</k></ks>     ) 	<kc>//2</kc>
println(  <ks>modulo(5)<k>(3)</k></ks>     ) 	<kc>//3</kc>
</pre> </td>
<td><h3>Function as return value</h3>
<center><img src="./img/funRetFun.png" alt="funRetFun.png" width="30%"/></center>
<m>  </m> </td>
</tr>




<tr>
<td><pre>
</pre> </td>
<td><m><em></em></m> </td>
</tr>

<tr>
<td><pre>
fun sToN( s: String, base: Int<k>=10</k> ) : Int{
    var v = 0
    for( i <ks>in</ks> 0..s.length-1 ) {
        v = ( s[i].toInt()-48 ) + v*base
    }
    return v
}
<kc>------</kc>
println( " ${ sToN( <k>s=</k>"123") } " ) 	<kc>//123</kc>
</pre> </td>
<td><m><em>Default parameters</em> and <em>Named parameters</em> at call </m> </td>
</tr>




<tr>
<td><pre>
fun mirror(v: Int) : <k>Pair&ltInt,Int></k> {
	return Pair(v, -v)
}
val v = mirror(2)
<kc>------</kc>
println("${v.first}, ${v.second} ")  <kc>//2,-2</kc>

val(pos,neg) = mirror(3)
<kc>------</kc>
println( " pos=$pos neg=$neg " ) 	<kc>//pos=3 neg=-3</kc>  
</pre> </td>
<td><m><em>Multiple return values</em>. To extract the values into separate values, we can exploit
<bc>destructuring declarations</bc> (syntactic sugar)</m> 
<pre>
val(pos,neg) = mirror(3)
</pre>
</td>
</tr>



<td><pre>val sToNref = <k>::</k>sToN
println( sToNref )	
	<kc> //fun sToN(kotlin.String, kotlin.Int): kotlin.Int</kc> 
-------------------------
fun add( x:Int, y:Int ) : Int { return x+y }
println( <ks>exec23( <k>::add</k> )</ks> )				<kc>//5</kc>

val x = <ks>(<k>::add</k>)(5,6)</ks>	<kc>//call using a funref</kc>
println( x ) 		<kc>//11</kc>

</pre> 
<!--
<m>To obtain the output, include the dependency on:</m>
<pre>
<k>implementation</k> "org.jetbrains.kotlin:kotlin-reflect"
</pre>
-->
</td>
<td><h3>Function reference</h3>
<m>The</m> <bc>::</bc>  <m>operator creates a member reference or a (statically known) class reference.<br/>
The <em>reference</em> is a value of type <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-class/index.html" target="web">KClass</a>.<br/>
A Kotlin class reference is not the same as a Java class reference. To obtain a Java class reference, 
use the <bc>.java</bc> property on a <tt>KClass</tt> instance.</m>
 </td>
 
  
 <tr>
<td><pre>
var str = "Hello World"
<ks>str</ks><k>.let</k> { println("$<k>it</k>!!") }	<kc>//Hello World!!</kc>

<ks>137</ks><k>.let</k>  { println("$<k>it</k>!!") }	<kc>//137!!</kc>
 </pre> </td>
<td>
<h3>Standard library function <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/let.html" target="web"><k>let</k></a></h3> 
<m>
<em>let</em>  takes the object it is invoked upon as the parameter and returns the result of the lambda expression.<br/>
It is a 
<a href="https://kotlinlang.org/docs/reference/scope-functions.html" target="web"><k>scope function</k></a>,
 wherein the variables declared inside the expression cannot be used outside.
<!-- https://www.journaldev.com/19467/kotlin-let-run-also-apply-with  useful higher order functions implementing idiomatic patterns.-->
</m>
 
</td>
</tr>

<tr>

 
<tr>
<td><pre>
fun testRunFunction() {
    val logo = "Starting"
    val <k>v1 = run { </k>
        println("First start:$logo  ${curThread()}")
        val logo = "First"	<kc>//local</kc>
        println("First ended : $logo")
        logo
    <k>}</k>
    val <k>v2 = run { </k>
        println("Second start:$logo ${curThread()}")
        val logo = "Second"	<kc>//local</kc>
        println("Second ended: $logo ")
        logo
    <k>}</k>
    println("logo=$logo v1=$<ks>v1</ks> v2=$<ks>v2</ks>" )
}

testRunFunction()

</pre> 
</td>
 
<td> 
<h3>Standard library function <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/run.html" target="web"><k>run</k></a></h3> 
<m>
<em>run </em> calls the specified function block and returns its result.<br/>
    It is a combination of <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/with.html" target="web"><k>with</k></a> and 
	<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/let.html" target="web"><k>let</k></a>
	library functions.<br/>
	Similar to the <tt>let</tt> function, the run function returns the last statement.<br/>
	Unlike <tt>let</tt>, the <tt>run</tt> function <k>doesn’t support the it</k> keyword.
 </m>
<pre>
<kc>//OUTPUT</kc>
First start:Starting  thread=main | nthreads=1
First ended : First
Second start:Starting thread=main | nthreads=1
Second ended: Second 
logo=Starting v1=First v2=Second
</pre>
</td>
</tr>
 
</tbody>	
</table></center>
 

<h2><a id="clos"/>Closures, Callbacks and CPS</h2>
These examples are reported in  <a href="../src/kotlindemo/demoCps.kt" target="code">demoCps.kt</a>  (project <m><ks>it.unibo.kotlinIntro</ks></m>).
<br/><br/>

<center><table style="width:95%">
<tbody>	
<tr>
<td style="width:45%"><pre>
fun counterCreate()  : ( cmd : String ) -> Int {
    <ks>var localCounter = 0</ks>
    return { msg ->
        when (msg) {
            "inc" -> ++localCounter
            "dec" -> --localCounter
            "val" -> localCounter
             else -> throw Exception( "unknown" )
        }
    }
}

val c1 = <ks>counterCreate()</ks>
<kc>------</kc>
for( i in 1..3 ) <ks>c1("inc")</ks>
println("c1=${<ks>c1("val")</ks>}")	      <kc>//c1=3</kc>

val c2 = <ks>counterCreate()</ks>		<kc>//another instance</kc>
<kc>------</kc>
for( i in 1..3 ) <ks>c2("dec")</ks>
println("c2=${<ks>c2("val")</ks>}")	     <kc>//c2=-3</kc>
</pre> </td>
<td>
<h3>Lexical Closures</h3>
<m>The <em>closure</em> returned by <bc>counterCreate</bc> is "closed over" the variable <bc>localCounter</bc>.<br/>
We are reproducing <ks>oo</ks> programming style (<i>instance</i> and <i>state encapsulation</i>)</m> </td>
</tr>



<tr>
<td><pre>
fun showAction( msg: String ){
    println( msg )
}
fun readAction() : String{
    println("readaction  ... | ${curThread()}")
    return "myinput"
}
fun evalAction( v: Int, msg: String ) : String{
    println("evalaction ... | ${curThread()}")
    return "$msg:$v"
}

fun doJobNormal(n:Int){	<kc>//<ks>print- eval-read</ks> pattern</kc>
    <k>showAction( evalAction( n,readAction() )  )</k>
}
-----------------------
   doJobNormal(10)		<kc>//output : myinput:100</kc>
}

</pre> </td>
<td><h3>Normal flow</h3>
 With reference to the set of functions on the left, let us execute a <em>Normal call sequence</em>:
The output is:</m>
<pre>
<kc>//OUPUT</kc>
readaction  ... | thread=main | nthreads=1
evalaction ...  | thread=main | nthreads=1
myinput:100
</pre>

 
</td>
</tr>

<tr>
<td><pre>
fun readCps( <ks>callback</ks>:<k>( String )-> Unit</k> ) :Unit {
    println("readCps  ... | ${curThread()}")
    <k>callback( "myinputcps" )</k>
}

---------------------
  readCps( <ks>{ msg -> showAction(msg)</ks>  }
  readCps( <ks>showAction(<k>it</k>)</ks>  } <kc>//using  lambda  shortcut</kc>
</pre> </td>
<td> 
<h3><a href="https://en.wikipedia.org/wiki/Callback_(computer_programming)" target="web">Callbacks</a></h3> 
<m>
are quite common in <bc>event-loop</bc> architectures such as 
<a href="https://en.wikipedia.org/wiki/JavaScript" target="web"><b>JavaScript</b></a> /
<a href="https://en.wikipedia.org/wiki/Node.js" target="web"><b>Node.js</b></a>.
The idea is to pass one function as a parameter to another function, and have this one invoked once the process has completed.
</m> 
<pre>
<kc>//OUPUT</kc>
readCps  ... | thread=main | nthreads=1
myinputcps
</pre>
<m>  The usage of callbacks leads to the
 <em>Continuation-passing style</em>  (see <a href="https://en.wikipedia.org/wiki/Continuation-passing_style" target="web">CPS</a>),
 which is quite diffused to handle 
 <a href="https://en.wikipedia.org/wiki/Asynchronous_I/O" target="web">Asynchronous I/O</a>
</m>
</td>
</tr>

<tr>
<td><pre>
fun readCps( <ks>callback</ks>:<k>(String)-> Unit</k>  ):Unit{
    println("readCps  ... | ${curThread()}")
    <ks>callback</ks>( "myinputcps" )
}
fun evalCps(v:Int, msg:String, <ks>callback</ks>:<k>(String)-> Unit</k> ){
    println("evalCps ... | ${curThread()}")
    <ks>callback</ks>( "$msg: $v" )
}

fun <i>doJobCpsNoShortcut</i>( n: Int  ){
    readCps( <kc>//lambda</kc>
        { input : String-> evalCps( n, input, {<kc>//lambda</kc>
              msg ->  showAction( msg )  
            } 
        )}<kc>//evalCps</kc>
     )<kc>//readCps</kc>	
}

fun <b>doJobCps</b>( n: Int  ){ <kc>//using lambda shortcut</kc>
	<ks>readCps</ks><k>{ evalCps( n, it) { <ks>showAction( it )</ks>} } </k> 
} 
---------------------
  doJobCps( 10 }
</pre> </td>
<td>
<h3>CPS  (Continuation Passing Style)</h3>
<m>The example on the left trasforms the normal <ks>print-eval-read pattern</ks> into a 
pattern <k>read-and-after-do</k>
</m>

<pre>
<kc>//OUPUT</kc>
readCps  ... | thread=main | nthreads=1
evalCps ... | thread=main | nthreads=1
myinputcps:10
</pre>
 
<h3>Callback hell</h3>
<m>
In order to avoid the <bc>anti-pattern</bc> known as
 <a href="http://callbackhell.com/">callback hell</a>, people use other approaches such as 
 <a href="https://en.wikipedia.org/wiki/Futures_and_promises" target="web"><b>futures / promises</b></a> or 
<a href=" https://en.wikipedia.org/wiki/Reactive_extensions" target="web"><b>Reactive Extensions (Rx)</b></a>
(from <tt>C#</tt>, <tt>.NET</tt>) .
 </m> 

</td>
</tr>

</tbody>	
</table></center>

<h2 id="async">Towards Asynchronous Programming</h2>
This example is reported in  <a href="../src/kotlindemo/demoCpsAsynch.kt" target="code">demoCpsAsynch.kt</a>  
(project <m><ks>it.unibo.kotlinIntro</ks></m>).
<br/><br/>
<center><table style="width:95%">
<tbody>	

<tr>
<td style="width:50%">
Let us suppose that the operation <bc>readCps</bc> takes a long time and that we do not want to block
the computation. </td>
<td>


As a solution, modern langauages do introduce:

<ol>
<li>Threading</li>
<li>Callbacks</li>
<li> <a href="https://en.wikipedia.org/wiki/Futures_and_promises" target="web"><b>futures / promises</b></a>  
</li>
<li><a href=" https://en.wikipedia.org/wiki/Reactive_extensions" target="web"><b>Reactive Extensions (Rx)</b></a></li>
<li>Coroutines</li>
</ol>

<m></m>
</td>
</tr>



<tr>
<td>
<m>
As an example of <a href="https://en.wikipedia.org/wiki/Continuation-passing_style" target="web">CPS</a> in 
 <a href="https://en.wikipedia.org/wiki/Asynchrony_(computer_programming)" target="web">Asynchronous</a> programming,
let us simulate here the <tt>readCpsAsynch</tt> operation as an activity that runs in its own <bc>thread</bc>  and ends after <tt>3 sec</tt>.
</m>
<pre>
fun readCpsAsynch( <ks>callback</ks>:<k>(String)-> Unit</k> ) : Unit{
  <k>kotlin.concurrent.thread(start = true)</k> {
	println("readCpsAsynch  ... | ${curThread()} ")
	<ks>Thread.sleep(3000)</ks>	<kc>//Long-term action</kc>
	println("readCpsAsynch done")
	<ks>callback</ks>( "myinputasynchcps" )
  }
}

fun doJobAsynchCps( n: Int  ){
	<ks>readCpsAsynch</ks>{ <k>evalCps( n, it)</k> { <ks>showAction( it )</ks>}} 
}
</pre>
<m>
The package <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.concurrent/" target="web">kotlin.concurrent</a> includes 
utility functions for concurrent programming.
The function <k>thread</k> creates a thread that runs the specified 
<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.concurrent/thread.html#kotlin.concurrent$thread(kotlin.Boolean,%20kotlin.Boolean,%20java.lang.ClassLoader,%20kotlin.String,%20kotlin.Int,%20kotlin.Function0((kotlin.Unit)))/block" target="web">block</a>
of code.

</m>
<pre>
--------------------------
    doJobAsynchCps( 10  )
</pre> 
 
</td>
<td>
<h3>ASYNCHRONOUS PROGRAMMING WITH CPS</h3>
<m>Now, the <tt>main</tt> program ends immediately; the computation is executed in the thread activated for the input.
</m> 
<pre>
<kc>//OUPUT</kc>
BEGINS CPU=4 thread=main | nthreads=1
work done in time= 4
ENDS thread=main | nthreads=2
readCpsAsynch  ... | thread=Thread-0 | nthreads=1 
readCpsAsynch done 
evalCps ... | thread=Thread-0 | nthreads=2
myinputasynchcps:10
</pre>
<m> 
Note the <a href="https://kotlinlang.org/docs/reference/java-interop.html#sam-conversions" target="web">Single Abstract Method conversion</a> 
(<bc>SAM</bc>) in <tt>kotlin.concurrent.thread</tt>: when an object implements a <tt>SAM</tt> interface, we can pass a lambda instead.
</m> 
</td>
</tr>

</tbody>	
</table></center>

<h2><a id="coroutinesIntro"/>Introduction to coroutines</h2>

Overview:
<ol>
<li>A function can be activated as a <bc>coroutine</bc>, i.e. as a a sort of 'light-weight thread'.</li>
<li>A coroutine can invoke other functions; it can also <bc>suspend</bc> its behavior (without blocking its running thread). </li>
<li>Interaction among <a href="https://en.wikipedia.org/wiki/Concurrency_(computer_science) ">concurrent</a> activities (coroutines) can be
supported by <bc>channels</bc> that provide suspensive send/receive operations.
</li>
<li>Combining a coroutine with a channel to communicate with other coroutines makes the idea of <bc>actor</bc>.</li>
</ol>
<hr/>
<ul>
<li>Essentially, a 
  <a href="https://kotlinlang.org/docs/reference/coroutines/basics.html" target="web"><em>Coroutine</em></a> 
  is a light-weight thread that can be activated with a 
   <a href="https://www.educative.io/edpresso/coroutine-builders-launching-coroutines-in-kotlin" target="web"><em>Coroutine builder</em></a> 
 into a 
 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/" target="web"><em>CoroutineScope</em></a>.
<br/><br/></li>


<li>
Coroutines can be executed concurrently using a multi-threaded 
 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-dispatcher/index.html" target="web"><em>CoroutineDispatcher</em></a>
like the 
<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html"  target="web">Dispatchers.Default</a>.
It presents all the usual concurrency problems. 
See <a href="https://kotlinlang.org/docs/reference/coroutines/shared-mutable-state-and-concurrency.html" target="web">Kotlin Shared mutable state and concurrency</a>.
<br/><br/></li>

<li>By default, coroutines are run on a <b>shared pool of threads</b>. 
Threads still exist in a program based on coroutines, but <bc>one thread can run many coroutines</bc>, so there's no need for too many threads.

<center><img src="./img/coroutines.png" alt="coroutines.png" width="40%"/></center>
<br/><br/></li> 

<li>
Kotlin Coroutines enhance <a href="https://en.wikipedia.org/wiki/Asynchrony_(computer_programming)" target="web">Asynchronous</a> programming 
by being lightweight and essentially faster than a thread as they are <em>stackless</em>. 
What this means from a multiprocessing perspective, is that Kotlin Coroutines don't map on the native CPU thread, 
hence there's <bc>no context-switching</bc> on the processor.
<br/><br/></li>

<li>The execution of a coroutine always happens inside a 
<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/-coroutine-context/"  target="web">CoroutineContext</a> 
that defines <b>how</b> the coroutine will be executed.
It includes a coroutine <a href="https://kotlinlang.org/docs/reference/coroutines/coroutine-context-and-dispatchers.html" target="web"><k>Dispatcher</k></a>. 
A <em>Coroutine Context</em> can be composed  by several element types. <!-- to create <em>composed behaviors</em>. -->
<br/><br/></li>


<li>
Every coroutine has a context that is represented by an instance of 
<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/-coroutine-context/"  target="web">CoroutineContext</a> interface. 
A context is a set of elements and current coroutine context is available via <m><k>coroutineContext</k></m> property.<br/>
A <m><k>scope</k></m> is just a reference to a context.
<br/><br/></li>

<li>Coroutines are <bc>computations that can be  suspended</bc></m> without blocking a thread.
They are based on the concept of <em>Continuation-passing style</em> (<m><k>CPS</k></m>) programming.


<center><img src="./img/coroutineSuspend.png" alt="coroutineSuspend.png" width="40%"/></center>
<br/><br/></li>

<li>Coroutines do not rely on features of the <tt>Operating System</tt> or the <tt>JVM</tt>. Instead, a <bc>Continuation</bc> is added to every suspending function as 
an additional parameter according to the <bc>CPS</bc> style. The compiler produces a <em>state machine</em> to handle suspension.
<br/><br/></li>


<li>
A coroutine itself is represented by a 
<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html" target="web">Job</a>. 
It is responsible for coroutine's lifecycle, cancellation, and parent-child relations. 
A current job can be retrieved from a current coroutine's context.
<br/><br/></li>

<m></m>
</ul>

<h3>Examples</h3>
The examples hereunder are reported in  <a href="../src/kotlindemo/demoCoroutinesIntro.kt" target="code">demoCoroutinesIntro.kt</a>  
(project <m><ks>it.unibo.kotlinIntro</ks></m>).<br/>
The main program now waits for a command from the user to select the demo to run:
<hr/>
<pre>
var demoTodo : () -> Unit = { println("nothing to do") }

fun readInt() : Int { print(">"); return readLine()!!.toInt() }

fun <ks>doDemo</ks>( input : Int ){
	println("BEGINS CPU=$cpus ${curThread()}")
	<k>when( input )</k>{<m>
		1 ->  demoTodo =  { runBlockThread() }
		2 ->  demoTodo =  { GlobalScope.launch{ runBlockThread() } }
		3 ->  demoTodo =  { scopeDemo()								}
 		4 ->  demoTodo =  { scopeAsyncDemo()             	        }
		...
		else ->  { println("command unknown") }  //Note the block     </m>		
	} 			
	println( "work done in time= ${measureTimeMillis(  demoTodo )}"  )
	println("ENDS ${curThread()}")	
}

fun main() {
		var input =  readInt()
		while( input != 0 ){
			<ks>doDemo( input )</ks>
			demoTodo = 	{ println("nothing to do") }    
			input    =  readInt()
		}
  	    println( "BYE") 
}
</pre>
<hr/>

<center><table style="width:95%">
<tbody>	

<tr>
<td>
<h3>Conventional (Java) code</h3>
<pre>
var <ks>thcounter</ks>=0

fun <ks>runBlockThread( delay : Long = 0L )</ks>{	    
    //println("thread sleeps ... : ${curThread()}")
    <k>Thread.sleep(delay)</k> 
	thcounter++  <kc>//thcounter = thcounter + 1 NON ATOMICA</kc>
	println("thread ends : ${curThread()} thcounter=${thcounter}")
 <k>}</k>
 <!-- <k>run {</k> <kc>//Calls a function block; returns its result</kc> -->
<!-- } -->
------------------
runBlockThread(1500 )
</pre> </td>
<td><m>The current Thread (<tt>main</tt>) waits for <tt>1500</tt> msecs.<br></m>
<pre>
<kc>//OUTPUT</kc>
BEGINS CPU=4 thread=main | nthreads=1
thread ends : thread=main | nthreads=1 thcounter=1
work done in time= 1501
ENDS thread=main | nthreads=1
</pre>
</td>
</tr>



<tr>
<td>
 <h3><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/" target="web"><k>GlobalScope</k></a></h3> 
<m><ks>GlobalScope.launch</ks>  is used to launch <tt>top-level coroutines</tt>, which operate on the whole application lifetime. 
</m>
<pre>
<k>GlobalScope.launch{</k> <ks>runBlockThread()</ks> <k>}</k>
</pre> </td>
<td><m>
The <tt>runBlockThread</tt> is now called in the default Thread devoted to Coroutine execution. 
</m>
<pre>
<kc>//OUTPUT</kc>
BEGINS CPU=4 thread=main | nthreads=1
work done in time= 6
ENDS thread=main | nthreads=3
<ks>></ks><m>thread ends : thread=<k> DefaultDispatcher-worker-1</k>  | nthreads=4 thcounter=1</m>
</pre>
<m>
Note that the 'program' ends immediately. <br/>
The output after <ks>></ks> appears since our main waits for input. </m> 
</m>
</td>
</tr>


<tr>
<td>
<m>
The example above  shows that the coroutine works with reference to the <bc>Dispather.Deafault</bc>. <br/>
A <a href="https://kotlinlang.org/docs/reference/coroutines/coroutine-context-and-dispatchers.html" target="web"><k>Dispatcher</k></a>
determines the thread in which a coroutine will be executed. It can be provided by the <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html" target="web"> 
Coroutine Scope</a> or specified using a builder.

</td>
<td>
<h3>On <a href="https://kotlinlang.org/docs/reference/coroutines/coroutine-context-and-dispatchers.html" target="web"><k>Dispatchers</k></a></h3> 
<m>
A dispatcher can be provided in two ways:

<ul>
<li>By the<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html" target="web">. 
CoroutineScope</a> <br/><br/></li>
<li><bc>Explicitly</bc>: the coroutine builder receives a coroutine context as a first parameter.
<!-- See  <a href="#Dispatchers">Dispatchers</a> later on. -->
</li>
</ul>
</m>
</td>
</tr>

<tr>
<td>
 <h3><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html" target="web"> 
<k>Coroutine Scope</k></a></h3> 
  <m>defines a 
  <a href="https://en.wikipedia.org/wiki/Scope_(computer_science)" target="web"> <k>Scope</k></a> for new coroutines. 
  Every coroutine builder is an extension on CoroutineScope and inherits its 
  <a href="https://kotlinlang.org/docs/reference/coroutines/coroutine-context-and-dispatchers.html" target="web"><k>coroutineContext</k></a>
  to automatically propagate both context elements and cancellation.
 </m>  
<pre>
fun scopeDemo (){
	val scope = <k>CoroutineScope( Dispatchers.Default )</k>
	println( <ks>scope.coroutineContext</ks> )
	<k>scope.launch</k>{ runBlockThread() } 	
}
</pre> </td>
<td><m>
The <b>runBlockThread</b> is now called in a new Coroutine scope. 
</m>
<pre>
<kc>//OUTPUT</kc>
BEGINS CPU=4 thread=main | nthreads=4
<ks>[JobImpl{Active}@606d8acf, DefaultDispatcher]</ks>
work done in time= 2
ENDS thread=main | nthreads=4
><m>thread ends : thread=DefaultDispatcher-worker-2 | nthreads=4 thcounter=1</m>
</pre>
<m>
</m>
</td>
</tr>

<tr>
<td>
<pre>
val n=10000	<m><kc>//number of Thread or Coroutines to launch</kc></m>
val k=1000	<m><kc>//times an action is repeated by each Thread or Coroutine</kc></m>

fun <ks>manyThreads()</ks>{
	thcounter=0
 	val time = measureTimeMillis{
		val jobs = List(n){
		<ks>kotlin.concurrent.thread(start = true)</ks> {
			<kc>//println("thread ${iter++} starts ")</kc>
			repeat( k ){ runBlockThread() }
 		}
		}
		jobs.forEach{<k>it.join()</k>} <kc>//wait for termination of all threads</kc> 
 	}
	println("manyThreads time= $time thcounter=$thcounter")
}
</pre> </td>
<td>
 <h3>Many Threads</h3> 

<m>The function  <ks>manyThreads</ks> activates <tt>n=10000</tt> threads; each thread increments a global counter
<tt>k=1000 times</tt>.</m>
<pre>
<kc>//OUTPUT</kc>
BEGINS CPU=4 thread=main | nthreads=1
manyThreads time= <k>14811</k> counter=<k>9924712</k>
work done in time= 14812
ENDS thread=main | nthreads=1
</pre>
<m>Question: why the final value of the <tt>thcounter</tt> is not <tt>n*k = 10000000</tt>?.
</m>
</td>
</tr>


<tr>
<td>

<pre>
fun <ks>manyCoroutines()</ks>{
	val <k>scope</k> = CoroutineScope( Dispatchers.Default )
	var counter=0
	
	val time = measureTimeMillis {
		val jobs = List(n) { <k>scope.launch</k>{ repeat(k) { runBlockThread() } } }
		jobs.forEach { it.join() } <m><kc>//wait for termination of all coroutines</kc></m>
	}
	
	println("manyCoroutines time= $time counter=$counter")
 }
</pre> </td>
<td>
 <h3>Many Coroutines</h3> 

<m>The function  <ks>manyCoroutines</ks> activates <tt>n=10000</tt> coroutines; each coroutine increments a global counter
<tt>k=1000 times</tt>.</m>
<pre>
<kc>//OUTPUT</kc>
BEGINS CPU=4 thread=main | nthreads=1
work done in time= 11
ENDS thread=main | nthreads=3
>manyCoroutines time= <k>4271</k> thcounter=9478141 <kc>//!!!</kc>
</pre>
<m>The execution time is now much less than the case of using threads.<br/>
Question: why the final value of the <tt>thcounter</tt> is not <tt>n*k = 10000000</tt>?.
</m>
</td>
</tr>

</tbody>	
</table></center>

<h3>A closer look to coroutines</h3>
From  <a href="https://medium.com/@elizarov/coroutine-context-and-scope-c8b255d59055"  target="web">Elizarov</a> we know that:
<ul>
 

<li>
A coroutine is typically launched using 
<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html"  target="web"><bc>launch</bc></a>
coroutine builder:
<pre>
fun <k>CoroutineScope.launch</k>(		//<kc>extension function on CoroutineScope</kc>
    <ks>context</ks>: CoroutineContext = EmptyCoroutineContext,		//<kc>parameter</kc>
    // ...	
): <k>Job</k>
</pre>
<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html"  target="web"><bc>launch</bc></a>
 is defined as an extension function of the
<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/-coroutine-context/"  target="web">CoroutineScope</a> interface
that consists of a sole property (<m><kc>val  coroutineContext: CoroutineContext</kc></m>).
<br/>
 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/-coroutine-context/"  target="web">CoroutineScope</a>   merges (using the 
 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/-coroutine-context/plus.html"  target="web"><bc>plus</bc></a>
operator of the context) the scope context with the <m><ks>context</ks></m> parameter, 
whose elements are taking precedence over the elements from the scope context. <br/>
The resulting context is 
the parent context of the new coroutine. The new coroutine creates its own child 
<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html" target="web">Job</a> instance (using a job from this context as its parent) 
and defines its child context as a parent context plus its job.<br/>

<center><img src="./img/coroutinesScopes.png" alt="coroutinesScopes.png" width="70%"/></center>
<br/><br/></li>

<li>
By convention, a context in 
<a href="https://kotlinlang.org/docs/reference/coroutines/coroutine-context-and-dispatchers.html#coroutine-scope"  target="web">CoroutineScope</a> 
contains a <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html" target="web">Job</a> 
that is going to become a parent of new coroutine 
(with the exception of <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/" target="web">GlobalScope</a>
that you should avoid anyway - see: 
<a href="https://medium.com/@elizarov/the-reason-to-avoid-globalscope-835337445abc" target="web">The reason to avoid GlobalScope</a>).
<br/><br/></li>

 
<li>
The difference between a context and a scope is in their intended purpose:
	<ul>
	<li>
	The intended purpose of  <a href="https://kotlinlang.org/docs/reference/coroutines/coroutine-context-and-dispatchers.html#coroutine-scope"  target="web">CoroutineScope</a>
	receiver in launch and in all the other coroutine builders is to reference 
	a scope in which new coroutine is launched.
	</li>

	<li>
	The intended purpose of 
	<m><kc>context:<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/coroutine-context.html"  target="web">CoroutineContext</a> </kc></m> parameter in launch is to provide additional context elements to override elements 
	that would be otherwise inherited from a parent scope.
	</li>
	</ul>
<br/></li> 
<li>Every coroutine builder function (like <tt>launch</tt>, <tt>async</tt>, <tt>runBlocking</tt>, etc.) :
	
	<ul>
	<li>is an extension on <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/-coroutine-context/"  target="web">CoroutineScope</a> interface
	and inherits its abstract read-only property <tt>coroutineContext: CoroutineContext</tt> to  automatically propagate both context elements and cancellation.
	<ul>
		<li><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/" target="web">GlobalScope</a>: the coroutine affects the whole Application</li>
		<li><a href="https://kotlinlang.org/docs/reference/coroutines/coroutine-context-and-dispatchers.html#coroutine-scope"  target="web">CoroutineScope</a>: 
		defines a scope for new coroutines</li>
	</ul>
	 </li>

	<li>
	accepts as parameter one of the main <em>Dispatcher</em> (<tt>Default, IO, newSingleThreadContext , Unconfined, Main</tt>)
	 </li>

	<li>	
	  like every scoping function (<tt>coroutineScope, withContext</tt>, etc) 
	  provides its own scope with its own 
	  <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html" target="web">Job</a>
	  instance into the inner block of code it runs. <br/>
	  By convention, they all wait for all the coroutines inside their block to complete before completing themselves, 
	  thus enforcing the discipline of <m><k>structured concurrency</k></m>.<br/><br/>
	</li>
	</ul>

	<li>
All the <tt>coroutine builder</tt> functions (<bc>launch</bc>,<bc>async</bc>,...) accept as parameter one of the
following main Dispatchers:

<ul>
<li><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html" target="web">
<em>Default</em></a>: for CPU-intensive tasks. It can use as many threads as CPU cores.</li>
<li><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-i-o.html" target="web">
<em>IO</em></a>: IO-intensive tasks  waiting for an answer from another system. 
The size of this thread pool is 64.</li>
<li><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/new-single-thread-context.html" target="web">
<em>newSingleThreadContext</em></a> creates a new thread for the coroutine to run.</li>
<li><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-unconfined.html" target="web">
<em>Unconfined</em></a>: not confined -- will work with main thread (don’t use it unless you’re very sure of what you’re doing).</li>
<li><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-main.html" target="web">
<em>Main</em></a>: a special dispatcher that is included in <tt>UI</tt> related coroutine libraries.

</ul>
	
	</li>

 	</ul>

<h2><a id="dispatchers"/>Dispatchers</h2>
The examples hereunder are reported in  <a href="../src/kotlindemo/demoDispatchers.kt" target="code">demoDispatchers.kt</a>  
(project <m><ks>it.unibo.kotlinIntro</ks></m>).<br/>

<center><table style="width:95%">
<tr>
<td "width:45%">
<pre><kc>@kotlinx.coroutines.ObsoleteCoroutinesApi
@kotlinx.coroutines.ExperimentalCoroutinesApi</kc>
fun testDispatchers() {
runBlocking {
   <k>launch {</k> <kc>//context of the parent runBlocking </kc> 
   println("1) runBlocking | ${<ks>curThread()</ks>}")
  }
  <k>launch( <ks>Dispatchers.Unconfined</ks> )</k> { <kc>//in main thread </kc> 
   println("2) Unconfined | ${<ks>curThread()</ks>}")
  }
  <k>launch( <ks>Dispatchers.Default</ks> )</k> { <kc>//DefaultDispatcher </kc> 
   println("3) Default | ${<ks>curThread()</ks>)}")
  }
  <k>launch( <ks>newSingleThreadContext("MyThr")</ks> )</k> { <kc>//new thread </kc> 
   println("4) newSingleThreadContext | ${<ks>curThread()</ks>}")
  }
}
}
fun main(){
    println("BEGINS CPU=$cpus ${curThread()}")
	testDispatchers()
	println("BYE")
    println("ENDS ${curThread()}")
}
</pre> </td>
<td><m></m>
<!--
-Dkotlinx.coroutines.debug JVM option https://play.kotlinlang.org/koans/overview
-->
 
<pre>
<kc>//OUPUT</kc>
BEGINS CPU=4 thread=main / nthreads=2
2) Unconfined | thread=main / nthreads=2
3) Default | thread=DefaultDispatcher-worker-1 / nthreads=5
1) runBlocking | thread=main / nthreads=6
4) newSingleThreadContext | thread=MyThr / nthreads=6
BYE
ENDS thread=main / nthreads=6
</pre>
</td>
</tr>

</tbody>	
</table></center>

<h3>Experiments with Dispatchers</h3>
<ul>
<li>Coroutine dispatcher can confine coroutine execution to a specific thread, dispatch it to a thread pool, 
or let it run unconfined.</li>
<li>Coroutines can be executed concurrently using a multi-threaded dispatcher.</li>
<li>Coroutines can suspend on one thread and resume on another thread.</li>
</ul>

The examples hereunder are reported in  <a href="../src/kotlindemo/demoDispatcherPatterns.kt" target="code">demoDispatcherPatterns.kt</a>  
(project <m><ks>it.unibo.kotlinIntro</ks></m>).<br/>

<center><table style="width:95%">
<tr>
<td "width:45%">
 <pre>
fun action(i : Int) { println("hello $i ${curThread()}") }

suspend fun launchWithDefault(i:Int, <ks>scope</ks>:CoroutineScope){
    <ks>scope</ks>.launch( <k>Dispatchers.Default</k> ){ action(i) }
}

fun main() = runBlocking {
	println("BEGINS CPU=$cpus ${curThread()}")
    for (i in 1..6) <ks>launchWithDefault( i,this ) </ks>
	println("ENDS ${curThread()}")	
}
</pre> </td>
<td><h3>Dispatch.Default</h3>
<m>The actions are executed by as many Threads as the CPU cores</m> 
<pre>
<kc>//OUTPUT</kc>
BEGINS CPU=8 thread=main | nthreads=1
hello 1 thread=DefaultDispatcher-worker-1 | nthreads=4
hello 2 thread=DefaultDispatcher-worker-1 | nthreads=4
hello 3 thread=DefaultDispatcher-worker-1 | nthreads=4
hello 4 thread=DefaultDispatcher-worker-2 | nthreads=4
hello 5 thread=DefaultDispatcher-worker-2 | nthreads=6
hello 6 thread=DefaultDispatcher-worker-1 | nthreads=6
ENDS thread=main | nthreads=7
</pre> 
</td>
</tr>

<tr>
<td><pre>
suspend fun launchAction(i:Int,scope:CoroutineScope){
	launchIO(i,scope)
}
suspend fun launchIO( i:Int,<ks>scope</ks>:CoroutineScope){
    <ks>scope</ks>.launch( <k>Dispatchers.IO</k> ){ action(i) }
}
fun main() = runBlocking {
	println("BEGINS CPU=$cpus ${curThread()}")
    for (i in 1..10) <ks>launchWithDefault( i,this ) </ks>
	println("ENDS ${curThread()}")	
}

</pre> </td>
<td><h3>Dispatch.IO</h3>
<m>The actions are executed by a pool of (<tt>64</tt>) Threads.</m> 
<pre>
<kc>//OUTPUT</kc>
BEGINS CPU=8 thread=main | nthreads=1
hello 1 thread=DefaultDispatcher-worker-2 | nthreads=4
hello 2 thread=DefaultDispatcher-worker-2 | nthreads=4
hello 3 thread=DefaultDispatcher-worker-1 | nthreads=6
hello 4 thread=DefaultDispatcher-worker-3 | nthreads=7
hello 5 thread=DefaultDispatcher-worker-1 | nthreads=10
hello 7 thread=DefaultDispatcher-worker-1 | nthreads=11
hello 8 thread=DefaultDispatcher-worker-3 | nthreads=12
hello 10 thread=DefaultDispatcher-worker-1 | nthreads=13
hello 9 thread=DefaultDispatcher-worker-5 | nthreads=13
ENDS thread=main | nthreads=13
hello 6 thread=DefaultDispatcher-worker-6 | nthreads=13
</pre> 
</td>
</tr>

<tr>
<td><pre>
val th = newSingleThreadContext("My Thread")

suspend fun launchAction(i:Int,scope:CoroutineScope){
	launchSingle(i,scope)
}
suspend fun launchSingle(i:Int,scope:CoroutineScope){
    scope.launch( th ){ action(i) }
}

fun main() = runBlocking {
	println("BEGINS CPU=$cpus ${curThread()}")
    for (i in 1..10) <ks>launchWithDefault( i,this ) </ks>
	println("ENDS ${curThread()}")	
}
 
</pre> </td>
<td><h3>Thread confinement </h3>
<m>The actions are executed one a e time (in <tt>mutual exclusion</tt>).</m> 
by a <bc>single thread</bc>
<pre>
<kc>//OUTPUT</kc>
BEGINS CPU=8 thread=main | nthreads=1
hello 1 thread=My Thread | nthreads=2
hello 2 thread=My Thread | nthreads=2
hello 3 thread=My Thread | nthreads=2
ENDS thread=main | nthreads=2
hello 4 thread=My Thread | nthreads=2
hello 5 thread=My Thread | nthreads=2
hello 6 thread=My Thread | nthreads=2
</pre> 
</td>
</tr>


</tbody>	
</table></center>


<h2><a id="suspend"/>Suspending functions</h2>
A suspending function is just a regular Kotlin function with an additional <bc>suspend</bc> modifier which indicates that 
the function can suspend the execution of a coroutine. 
<center><img src="./img/coroutineSuspend1.png" alt="coroutineSuspend1.png" width="40%"/></center>


Suspending functions can invoke any other regular functions, but to actually suspend the execution, it has to be another suspending function.
<br/><br/>
The examples hereunder are reported in  <a href="../src/kotlindemo/demoSuspended.kt" target="code">demoSuspended.kt</a>  
(project <m><ks>it.unibo.kotlinIntro</ks></m>).
<br/><br/>
<!--
The main program now waits for a command from the user to select the demo to run:
<hr/>
<pre>
</pre>
<hr/>
-->
<center><table style="width:95%">
<tbody>	
<tr>
<td>
<h3>launch & runBlocking</h3> 
<m><bc>runBlocking</bc> is a  <tt>Coroutine Builder</tt> wrapper that runs new coroutine and blocks current thread interruptibly until its completion. 
<br/>
Using <bc>launch</bc>, the coroutine is launched in the
scope of the outer coroutine (that of <bc>runBlocking</bc> in this case). 
</m>
<pre>
fun main() = <k>runBlocking</k> { 
	println("BEGINS CPU=$cpus ${curThread()}")
	<k>launch{</k>  runBlockThread()  <k>}</k>	
	println("ENDS ${curThread()}")	
}
</pre> </td>
<td><m>
No <tt>Thread.sleep</tt> tis required now.  <br/>
</m>

<pre>
<kc>//OUTPUT</kc>
BEGINS CPU=4 thread=main | nthreads=1
ENDS thread=main | nthreads=1
thread sleeps ... : thread=main | nthreads=1
thread ends : thread=main | nthreads=1
</pre>
<m>
Since we use <bc>launch</bc> instead of <bc>GlobalScope.launch</bc>, then the coroutine is launched in the
scope of the outer <bc>runBlocking</bc> coroutine.<br/>
This is an example of  
<a href="https://kotlinlang.org/docs/reference/coroutines/basics.html#structured-concurrency" target="web">structured concurrency</a>:
coroutines confined to different scopes  are more maintainable and manageable.

<!-- <bc>runBlocking</bc>  is designed to bridge regular blocking code to libraries written in suspending style, 
to be used in main functions and in tests. -->
</m>
</td>
</tr>


<tr>
<td>
<h3>Launch and join</h3> 
<m>Coroutines started by  <bc>launch</bc> return a <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html" target="web">Job</a>
 immediately,  which we can use to <tt>cancel</tt> 
the computation or <em>await</em> its completion with <bc>join</bc>.</m> 
<pre>
fun main() =  <k>runBlocking</k> {  
	println("BEGINS CPU=$cpus ${curThread()}")
	<k>val job</k> =  <k>launch</k>{ runBlockThread()  }
	<k>job.join()</k>
 	println("ENDS ${curThread()}")
}
</pre> 
</td>
<td><m>
<br/>
</m>

<pre>
<kc>//OUTPUT</kc>
BEGINS CPU=4 thread=main | nthreads=1
thread sleeps ... : thread=main | nthreads=1
thread ends : thread=main | nthreads=1
ENDS thread=main | nthreads=1
</pre>
<m>
We can remove the explicit <bc>join</bc>, since <tt>runBlocking</tt> won't complete before all of its 
child coroutines finish.
</m>
</td>
</tr>



<tr>
<td>
<h3>delay</h3> 
<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html" target="web">Kotlin delay</a>
is a special <i>suspending function</i> that does not block a thread, but suspends the work.
<hr/>
A function that can <bc>suspend</bc> its work cannot be called from a normal function,
but only from <k>another suspend</k> function or from a <em>Coroutine</em>.
<hr/>
</m> 
<pre>
<k>suspend</k> fun ioBoundFun(){
	val <ks>timeElapsed</ks> = <ks>measureTimeMillis</ks> {
		println("IO operation | STARTS in ${curThread()}")
		<k>delay</k>(1000)
	}
	println("IO operation | Done, TIME=<ks>$timeElapsed</ks>")
}

fun main() =  <k>runBlocking</k> {  
	println("BEGINS CPU=$cpus ${curThread()}")
	<ks>ioBoundFun()</ks>
	println("ENDS ${curThread()}")
}
</pre> </td>
<td>
<pre>
<kc>//OUTPUT</kc>
BEGINS CPU=4 thread=main | nthreads=1
IO operation | STARTS in thread=main | nthreads=1
IO operation | Done, TIME=1021
ENDS thread=main | nthreads=1
</pre>
<m>If we execute:</m>
<pre>
fun main() =  <k>runBlocking</k> {  
	<k>launch</k>{ <ks>ioBoundFun()</ks> }
	println("BYE")
}
</pre>
<m>the output is:</m>
<br/>
<pre>
<kc>//OUTPUT</kc>
BEGINS CPU=4 thread=main | nthreads=1
ENDS thread=main | nthreads=1
IO operation | STARTS in thread=main | nthreads=1
IO operation | Done, TIME=1006
</pre>

</td>
</tr>
 

 <tr>
<td>
<h3>Coroutine builder <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html" target="web"><k>async</k></a> </h3>
<m>The 
<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html" target="web">async</a>
coroutine builder creates new coroutine and returns a 
<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/promise.html" target="web"><b>promise</b></a>, 
(of type <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/" target="web">Deferred</a>
in Kotlin): it promises to compute a value which we can wait for or  request at any time.
</m>
<pre>
<k>suspend</k> fun <ks>activate()</ks>{	
	val <ks>scope</ks> = CoroutineScope( Dispatchers.Default ) 
	val job1 = <k><ks>scope</ks>.async</k>{ ioBoundFun() }
	val job2 = <k><ks>scope</ks>.async</k>{ ioBoundFun() }
	if( ! job1.isCompleted || ! job2.isCompleted ) 
		println("Waiting for completion")
	val end1 = <k>job1.await()</k>	<m><kc>//only from a coroutine or another suspend</kc></m> 	 
	val end2 = <k>job2.await()</k>
	println("All jobs done; end1=$end1 end2=$end2")
}

fun main() = <k>runBlocking</k>{
	println("BEGINS CPU=$cpus ${curThread()}")
	<ks>activate()</ks>
	println("ENDS ${curThread()}")
}
</pre> </td>
<td><m>
<br/><br/>
 The method <bc>await</bc> on the promise allows us to get the value.


</m> 
<pre>
<kc>//OUPUT</kc>
BEGINS CPU=4 thread=main | nthreads=1
Waiting for completion
IO operation | STARTS in thread=DefaultDispatcher-worker-2 | nthreads=5
IO operation | STARTS in thread=DefaultDispatcher-worker-1 | nthreads=5
IO operation | Done, TIME=1011
IO operation | Done, TIME=1011
All jobs done; end1=kotlin.Unit end2=kotlin.Unit
ENDS thread=main | nthreads=6
</pre>

<m>There is a laziness option to async using an optional start parameter with a value of <bc>CoroutineStart.LAZY</bc>. 
It starts coroutine only when its result is needed by some await or if a start function is invoked.</m>
<br/><br/>
See also
<a href="https://kotlinlang.org/docs/reference/coroutines/composing-suspending-functions.html" target="web">Composing Suspending Functions</a>
</td>
</tr>



</tbody>	
</table></center>

 
<h2><a id="channels"/>Kotlin Channels</h2>
<ul>
<li>Kotlin <a href="https://kotlinlang.org/docs/reference/coroutines/channels.html" target="web">Channels</a>
(see also
<a href="https://play.kotlinlang.org/hands-on/Introduction%20to%20Coroutines%20and%20Channels/08_Channels" target="web">Kotlin Channels</a>
in  <a href="https://play.kotlinlang.org/hands-on/overview" target="web">Kotlin Hands-On</a>)
 provide a way to transfer a <tt>streams of values</tt>.
 <center><img src="./img/UsingChannelManyCoroutines.png" alt=" UsingChannelManyCoroutines.png" width="70%"/></center>
 <br/><br/></li>
 
 <li>
 A <a href=" https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-channel/index.html" target="web">
 Channel</a> is conceptually very similar to <bc>BlockingQueue</bc>. 
 One key difference is that instead of a blocking <tt>put</tt> operation it has a <bc>suspending send</bc>, 
 and instead of a blocking <tt>take</tt> operation it has a <bc> suspending receive</bc>.
 They are used for providing and consuming objects from the channel, implemented with a <tt>FIFO</tt>
strategy.

<center><img src="./img/liveCoroutine.gif" alt="liveCoroutine.gif" width="50%"/></center>


  <br/><br/></li>
 
 
<li>The sender is suspended when the channel is full
and resumes as soon as the receiver consumes the data. This concept is often referred to as 
<a href="https://www.reactivemanifesto.org/glossary#Back-Pressure" target="web"><bc>Backpressure</bc> (<i>Reactive Manifesto Glossary</i>) </a> 

and helps to prevent a channel from being flooded with more elements than the receivers can actually process. 
<br/><br/></li>
<li>
Kotlin defines several types of channels:
<br/>

	<em>Unbuffered Channels</em>:
	<ul>
	 <li><bc>RendezvousChannel</bc> (the buffer has capacity <tt>0</tt> and the sender suspends until the element is consumed)</li>
	</ul>

	<em>Buffered Channels</em>:
	<ul>
	<li><bc>LinkedListChannel</bc></li>
	<li><bc>ArrayChannel</bc></li>
	<li><bc>ConflatedChannel</bc> (the buffer has capacity <tt>1</tt> and the sender overrides an element not cosumed)</li>
	</ul>
</li>
</ul>
<hr/>
The examples hereunder are reported in  <a href="../src/kotlindemo/demoChannels.kt" target="code">demoChannels.kt</a>  (project <m><ks>it.unibo.kotlinIntro</ks></m>).
<br/><br/>
 
<center><table style="width:95%">
<tbody>	
<tr>
<td style="width:45%"><pre>
<k>suspend</k> fun channelTest(scope : CoroutineScope){
val n = 5
val <ks>channel</ks> = <k>Channel&ltInt>(2)</k> <kc>//ArrayChannel capacity=2 size=0</kc>

     val sender = scope.launch {
         repeat( n ) {
             <ks>channel</ks><k>.send( <ks>it</ks> )</k>
             println("SENDER | sent $it in ${curThread()}")
         }
     }
     
	 <ks>delay(500)</ks> <kc>//The receiver starts after a while ...</kc>
     
	 val receiver = scope.launch {
         for( i in 1..n ) {
             val v = <ks>channel</ks><k>.receive()</k>
             println("RECEIVER | receives $v in ${curThread()}")
         }
     }
}
 
fun main() = runBlocking{
	println("BEGINS CPU=$cpus ${curThread()}")
	<ks>channelTest( this )</ks>
	println("ENDS ${curThread()}")
}
 </pre> </td>
<td><m>
The example shows the usage of an <bc>ArrayChannel</bc> of capacity <tt>2</tt>. 
</m>

<pre>
<kc>//OUTPUT</kc>
BEGINS CPU=4 thread=main | nthreads=4
SENDER | sent 0 in thread=main | nthreads=4
SENDER | sent 1 in thread=main | nthreads=4
ENDS thread=main | nthreads=4
RECEIVER | receives 0 in thread=main | nthreads=4
RECEIVER | receives 1 in thread=main | nthreads=4
RECEIVER | receives 2 in thread=main | nthreads=4
SENDER | sent 2 in thread=main | nthreads=4
SENDER | sent 3 in thread=main | nthreads=4
SENDER | sent 4 in thread=main | nthreads=4
RECEIVER | receives 3 in thread=main | nthreads=4
RECEIVER | receives 4 in thread=main | nthreads=4
</pre>


</td>
</tr>

</tbody>	
</table></center>

<div class="remark">
Motto: Do not communicate by sharing memory; instead, share memory by communicating.
</div>

 
 


<h2><a id="kotlinprodcons"/>Producers-consumers in Kotlin</h2>

<ul>
<li>The pattern where a coroutine is  producing a sequence of elements is quite common. 
This is a part of <em>producer-consumer pattern</em> that is often found in concurrent code. 
You could abstract such a producer into a function that takes <bc>channel</bc> as its parameter, 
but this goes contrary to common sense that results must be returned from functions.
<br/><br/>
</li>
<li>There is a convenient coroutine builder named 
<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/produce.html"  target="web"><bc>produce</bc></a>
 that makes it easy to do it right on producer side, 
and an extension function <bc>consumeEach</bc>, that replaces a for loop on the consumer side.
<br/><br/>
</li>
<li>The coroutine builder 
<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/produce.html"  target="web"><bc>produce</bc></a> 
is associated with the channel that it sends elements to (a 
<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/"  target="web"><bc>ReceiveChannel</bc> </a>
interface) requires a specific <tt>CoroutineContext</tt> (as with <bc>launch</bc> or <bc>async</bc>) and works as follows:
<ul>
<li>suspends after a value is produced and  resumes when a new value is requested (similar to suspending sequences and iterators)</li>
 
<li>the body of the suspending lambda that is passed can suspend at any point</li>
<li>a value from a producer can only be received in a suspending computation </li>
<li>the channel has <em>no buffer</em> by default is closed when the coroutine completes</li>
</ul>
</li>
 
</ul>
<m></m>
 
<center><table style="width:98%">
<tbody>	

<tr>
<td style="width:45%">
<h3 id="produce">Coroutine builder 
<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/produce.html"  target="web"><bc>produce</bc></a></h3>
<pre>
 
val <ks>simpleProducer</ks> : <k>ReceiveChannel&lt;Int>?</k> = null

fun startProducer(scope : CoroutineScope ){
	simpleProducer = <k>scope.produce</k> {
		for( i in 1..3 ){
			<k>send( i )</k>
			println( "producer produced $i in  ${curThread()}")
		}
  }

<k>suspend</k> fun consume(){
    val v = <ks>simpleProducer!!</ks>.<k>receive()</k>
    println( "consume receives ${v} in ${curThread()}" )
    <ks>simpleProducer!!</ks>.<k>consumeEach</k> {
         println( "consume receives $it in ${curThread()}" )
    }
}

fun main() = <k>runBlocking</k>{
	println("BEGINS CPU=$cpus ${curThread()}")
	println( this ) <kc>//BlockingCoroutine{Active}@...</kc>
	<ks>startProducer(this); 
	consume()</ks>
	println("ENDS ${curThread()}")
}
</pre>
</td>
<td>
This example is reported in <a href="../src/prodCons/simpleProducerKotlin.kt" target="code">simpleProducerKotlin.kt</a>
<hr/>
<br/> 
<m>  
The coroutine builder <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/produce.html" target="web"><bc>produce</bc></a> 
takes a suspending lambda as a parameter; only the code within this lambda can send items to the channel.
The channel has <em>no buffer by default</em>; it is closed when the coroutine completes
</m>
<br/> 
<pre>
<kc>//OUTPUT</kc>
BEGINS CPU=8 thread=main | nthreads=1
BlockingCoroutine{Active}@799f7e29
producer produced 1 in  thread=main / nthreads=1
consume receives 1 in thread=main / nthreads=1
consume receives 2 in thread=main / nthreads=1
producer produced 2 in  thread=main / nthreads=1
producer produced 3 in  thread=main / nthreads=1
consume receives 3 in thread=main / nthreads=1
ENDS thread=main | nthreads=1
</pre>
<m> </m>
 
</td>
</tr>

<tr>
<td>
<h3>Many-type producer</h3>

<pre>
val <ks>context</ks> = newSingleThreadContext("myThread")
var producer : <k>ReceiveChannel<Any>?</k> <ks>= null</ks>

fun createProducer(<ks>scope</ks> : CoroutineScope ){
    producer = <k><ks>scope</ks>.produce(<ks>context</ks>, 0)</k>{ <kc>//capacity=0</kc>
		<k>send(5.2)</k>
		println( "producer sent 5.2 in ${curThread()}")
		<k>send("a")</k>
		println( "producer sent a   in ${curThread()}")
		<k>send(100)</k>
		println( "producer sent 100 in ${curThread()}")
   }
}

suspend fun doconsume(){
	val v = <k><ks>producer!!</ks>.receive()</k>		<kc>//the first item</kc>
	println( "doconsume receives1 $v in ${curThread()}")
	<k><ks>producer!!</ks>.consumeEach</k> { 
	println( "doconsume receives2 $it in ${curThread()}") }
}

fun main() = runBlocking{ 
    println("BEGINS CPU=$cpus ${kotlindemo.curThread()}")
		createProducer(this);
		doconsume()
    println("ENDS ${kotlindemo.curThread()}")
}

</pre>
</td>
<td>
This example is reported in <a href="../src/prodCons/prodConsKotlin.kt" target="code">prodConsKotlin.kt</a>
<hr/>
<br/> 

<m>When channel <bc>capacity = 0</bc> (default), the output is:</m> 
<pre>
<kc>//OUTPUT</kc>
BEGINS CPU=8 thread=main | nthreads=1
producer sent 5.2 in thread=myThread / nthreads=2
doconsume receives1 5.2 in thread=main / nthreads=2
doconsume receives2 a in thread=main / nthreads=2
producer sent a   in thread=myThread / nthreads=2
doconsume receives2 100 in thread=main / nthreads=2
producer sent 100 in thread=myThread / nthreads=2
ENDS thread=main | nthreads=2
</pre>

<m>When channel <bc>capacity = 1</bc>, the output is:</m>

<pre>
<kc>//OUTPUT</kc>
BEGINS CPU=8 thread=main | nthreads=1
producer sent 5.2 in thread=myThread / nthreads=2
doconsume receives1 5.2 in thread=main / nthreads=2
doconsume receives2 a in thread=main / nthreads=2
producer sent a   in thread=myThread / nthreads=2
producer sent 100 in thread=myThread / nthreads=2
doconsume receives2 100 in thread=main / nthreads=2
ENDS thread=main | nthreads=2
</pre>
 
 
 
</td>
</tr>

<tr>
<td style="width:45%">
<h3>Many consumers</h3>
<pre>
val <ks>aProducer</ks>:<k>ReceiveChannel&lt;Int>=GlobalScope.produce</k>{
    for( i in 1..3 ){
        println( "aProducer produces $i in ${curThread()}")
        <k>send( i )</k>
    }
}

fun consumer1(scope: CoroutineScope){
 <k>scope.launch</k>{
	delay(100)
	val v = <ks>aProducer</ks>.<k>receive()</k>
	println( "consumer1 receives ${v} in ${curThread()}" )
 }
}
fun consumer2(scope: CoroutineScope){
 <k>scope.launch</k>{
	for( i in 1..2 ) {
	  val v = <ks>aProducer</ks>.<k>receive()</k>
	  println("consumer2 receives ${v} in ${curThread()}")
	  delay(100)
	}
 }
}

fun main() = runBlocking{
  println( "BEGIN")
  consumer1(this )
  consumer2(this)
  println( "END")
}
</pre>
</td>
<td>
This example is reported in <a href="../src/prodCons/prodManyConsKotlin.kt" target="code">prodManyConsKotlin.kt</a>
<br/><br/>

<br/>The output is:</m>
<pre>
<kc>//OUTPUT</kc>
aProducer produces 1 in thread=DefaultDispatcher-worker-1 / nthreads=4
BEGINS CPU=4 thread=main | nthreads=4
ENDS thread=main | nthreads=4
consumer2 receives 1 in thread=main / nthreads=4
aProducer produces 2 in thread=DefaultDispatcher-worker-1 / nthreads=4
aProducer produces 3 in thread=DefaultDispatcher-worker-1 / nthreads=4
consumer1 receives 2 in thread=main / nthreads=4
consumer2 receives 3 in thread=main / nthreads=5
</pre>
 
 
</td>
</tr>

</tbody>	
</table></center>
 
 
<h2><a id="actors"/><a href="https://kotlinlang.org/docs/reference/coroutines/shared-mutable-state-and-concurrency.html#actors" target="web">Kotlin Actors</a></h2>
<!-
Writing complex actors #87   https://github.com/Kotlin/kotlinx.coroutines/issues/87#issuecomment-317207589
->
Using coroutines and channels, we can build a system that encapsulate mutable state in a manner that do not need 
any locks and synchronization and instead leverage a protocol of messages to handle concurrent updates of that state.
Such a model is called an <bc>actor</bc>. <br/> 
It is not a new concept, instead it has been around for years 
(see <a href="https://en.wikipedia.org/wiki/Actor_model" target="web">Actor model</a> ) 
and is the underlying concept of <a href="https://www.erlang.org/" target="web">Erlang</a>
 and can also be used in Java and Scala using 
<a href="https://doc.akka.io/docs/akka/current/typed/guide/introduction.html" target="web">Akka</a>.
<ul>
<li>An actor is an entity made up of a combination of a <em>coroutine</em>, the state that is confined and encapsulated into this coroutine, 
and a <em>channel</em> to communicate with other coroutines. 
<br/> <br/> </li>
<li>The coroutine builder named  <k>actor</k> conveniently combines actor’s mailbox channel into its scope to receive messages from 
and combines the send channel into the resulting job object, so that a single reference to the actor can be carried around as its handle.
<br/><br/>  
</li>
<li>The <bc>actor</bc> <i>coroutine builder</i> <em>is a dual of</em> <bc>produce</bc> <i>coroutine builder</i>, 
since a producer is associated with the channel that it <i>sends</i> elements to.
<br/><br/>
</li>
<li>This combination of actor-related mechanisms opens the way to the concept of <em>state share by communication</em>.
</li>
</ul>
<m>
</m>

<h3>An example</h3>
<br/>
<center><table style="width:95%">
<tbody>	

<tr>
<td style="width:50%"><pre>
var senderActor   : SendChannel<String>?  = null
var receiverActor : SendChannel<String>?  = null

fun startReceiver( scope : CoroutineScope){
	receiverActor = <k>scope.actor<String></k> {  
		<kc>//actor is a coroutine builder (dual of produce)</kc>
		println("receiverActor STARTS")
		var msg = <k>channel.receive()</k>
		while( msg != "end"){
			println("receiverActor receives $msg")
			msg = <k>channel.receive()</k>
		}
		println("receiverActor ENDS")
	}
}

fun startSender( scope : CoroutineScope){
	senderActor = <k>scope.actor<String></k> {  
		<kc>//actor is a coroutine builder (dual of produce)</kc>
		println("senderActor STARTS")
 		<k>receiverActor!!.send("Hello1")</k>
		delay(500)
 		<k>receiverActor!!.send("Hello2")</k>
		delay(500)
		<k>receiverActor!!.send("end")</k>
		println("senderActor ENDS")
 	}
}

fun main() = runBlocking{
    println("BEGINS CPU=$cpus ${curThread()}")
 	startReceiver( this )
	startSender( this )
    println("ENDS ${curThread()}")
}
</pre>
</td>
<td>
This example is reported in  <a href="../src/kotlindemo/demoActors.kt" target="code">demoActors.kt</a>  (project <m><ks>it.unibo.kotlinIntro</ks></m>).
<br/><br/><br/>
<center><img src="./img/demoActor0.png" alt="demoActor0.png" width="70%"/></center>

<m>A Kotlin (experimental) 
<a href="https://kotlinlang.org/docs/reference/coroutines/shared-mutable-state-and-concurrency.html#actors" target="web">actor</a>:
<ul>
<li>has type (interface) <bc>SendChannel&ltT></bc>, where <bc>T</bc> is the type of message it can handle<br/></br></li>
<li>confines the access of its state to a single <bc>Coroutine</bc><br/></br></li>
<li>is associated with the 
<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-channel/" target="web"><bc>channel</bc></a>
(<tt>unbuffered</tt> by default ) that it receives messages from<br/></br></li>
<li>modifies the state by handling the messages received on its 
<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-channel/" target="web"><bc>channel</bc></a><br/></br></li>
<li>works in a message-driven way</li>
</ul>
</m>
</td>
</tr>

 
</tbody>	
</table></center>



<h3>An actor working as a counter</h3>
 
<ul>

<li>The first step of using an actor usually consists in defining a <bc>class of messages</bc> that an actor is going to process.
Kotlin's <a href="https://kotlinlang.org/docs/reference/sealed-classes.html"  target="web"><m><k>sealed classes</k></m></a> are well suited for that purpose. However,
In the next example, we will use a conventional class (<m><ks>CounterMsg</ks></m>).<br/><br/>
</li>
<li>The class <m><ks>CounterMsg</ks></m> defines a field of interface 
<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-completable-deferred/" target="web"><m><k>CompletableDeferred</k></m></a>.
It is a 
<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/" target="web"><m><k>Kotlin Deferred</k></m></a> 
that can be completed via public functions <bc>complete</bc> or <bc>cancel</bc>.
All functions on this interface and on all interfaces derived from it, are <bc>thread-safe</bc> and can be safely invoked 
from concurrent coroutines without external synchronization.<br/><br/>
</li>


<li>We will use also (in function <tt>sendManyMessages</tt>) an 
<a href="https://kotlinlang.org/docs/reference/extensions.html" target="web">
<bc>Extension function</bc></a> on <tt>CoroutineScope</tt> that 
launches <tt>n</tt> coroutines all doing the same action <tt>k</tt> times and measures the completion time:
<pre>
suspend fun <k>CoroutineScope.manyRun</k>( action: <k>suspend () -> Unit</k> ) {
    val n=100		<kc>//number of coroutines to launch</kc>
    val k=1000		<kc>//times an action is repeated by each coroutine</kc>
    val time = measureTimeMillis {
        val jobs = List(n) {
            <k>launch</k> { repeat(k) { action() }  }
        }
        jobs.forEach { it.join() } <kc>//wait for termination of all coroutines</kc>
    }
    println("Completed ${n * k} actions in $time ms")
}

</pre>
</li>
</ul>
 


<m></m>
<br/>
This example is reported in  <a href="../src/kotlindemo/demoActorCounter.kt" target="code">demoActorCounter.kt</a>  (project <m><ks>it.unibo.kotlinIntro</ks></m>).
<br/><br/> 

<center><table style="width:95%">
<tbody>	
<tr>
<td style="width:55%">
<pre>
class <kc>CounterMsg</kc>(
	val cmd:String,
	val response: <k>CompletableDeferred&ltInt></k>?<ks>=null</ks>){
}

fun <ks>createCounter</ks>(scope : CoroutineScope):SendChannel&ltCounterMsg>{
 val counterActor = <k>scope.actor&lt;<kc>CounterMsg</kc>></k> {
	var k = 0 	<kc>//actor state</kc>
	for (<k>msg in channel</k>) { <kc>// iterate over incoming messages</kc>
	   <m>if( k>0 && k % 10000 == 0  && msg.cmd != "GET" )
		println("${msg.cmd} | $k in ${curThread()} full=${channel.isFull}")</m>
		when ( msg.cmd ) {
			<ks>"INC"</ks> -> k++
			<ks>"DEC"</ks> -> k--
			<ks>"GET"</ks> -> <k>msg.response?.complete</k>(k)
			<ks>"END"</ks> -> {println("counter closing ...");<k>channel.close()</k>}		
			else -> throw Exception( "unknown" )
		}
	  }
	}
 return counterActor
}

<k>suspend</k> fun <ks>showValue</ks>(<ks>counterActor</ks>: SendChannel&lt;CounterMsg>){
    val initVal = CompletableDeferred&lt;Int>()
    <ks>counterActor</ks>.<k>send</k>(<kc>CounterMsg</kc><ks>("GET", initVal))</ks>
    println("Counter VALUE=${<k>initVal.await()</k>}")	
}

<k>suspend</k> fun <ks>sendManyMessages</ks>( <ks>scope</ks> : CoroutineScope, 
		<ks>counterActor</ks>: SendChannel&lt;CounterMsg>){
    <ks>scope</ks>.<k>manyRun</k> {<ks>counterActor</ks>.<k>send</k>( <kc>CounterMsg</kc><ks>("INC")</ks>)}
}

fun main() = <k>runBlocking</k>{
    println("BEGINS CPU=$cpus ${curThread()}")

	val <ks>counter</ks> = createCounter( this )
	showValue( <ks>counter</ks> ) <kc>//initial value</kc>

	sendManyMessages(this, <ks>counter</ks>)
	showValue( <ks>counter</ks> )
	<kc>//TERMINATE THE COUNTER</kc>
	<ks>counter</ks>.<k>send</k>( CounterMsg(<ks>"END"</ks>) )
	println("JOIN ${curThread()}")
	<k>(counter as Job).join()</k>	<kc>//WAIT for counter termination</kc>
	<kc>//<ks>counter</ks>.close() //shutdown the actor</kc>

    println("ENDS ${curThread()}")
}
</pre>
<m></m> 
</td>
<td>
<center><img src="./img/demoActorCounter.png" alt="demoActorCounter.png" width="50%"/></center>
<pre>
<kc>//OUTPUT</kc>
BEGINS CPU=4 thread=main / nthreads=1  
Counter VALUE=0
counter INC | 10000 in thread=main / nthreads=1   full=true
counter INC | 20000 in thread=main / nthreads=1   full=true
counter INC | 30000 in thread=main / nthreads=1   full=true
counter INC | 40000 in thread=main / nthreads=1   full=true
counter INC | 50000 in thread=main / nthreads=1   full=true
counter INC | 60000 in thread=main / nthreads=1   full=true
counter INC | 70000 in thread=main / nthreads=1   full=true
counter INC | 80000 in thread=main / nthreads=1   full=true
counter INC | 90000 in thread=main / nthreads=1   full=true
Completed 100000 actions in 403 ms
Counter VALUE=100000
JOIN thread=main / nthreads=1  
counter END | 100000 in thread=main / nthreads=1   full=true
counter closing ...
ENDS thread=main / nthreads=1  </pre>

<h3>Actor termination</h3>
<m>
Note that the actor <k>counter</k> can be terminated:
<ul>
<li>From the inside, e.g.  : <k>channel.close()</k></li>
<li>From the outside, e.g. : <k>counter.close()</k></li>
</ul>
Moreover, we can await for actor termination by writing<br/>
<k>(counter as Job).join()</k>
</m> 
</td>
</tr>
</tbody>	
</table></center>
<!--
A simple actor can be written as a function, but an actor with a complex state  is better suited for a class.<br/>
-->

<h2 id="sequences">SEQUENCES (SUSPENDABLE)</h2> 

The examples hereunder are reported in  <a href="../src/kotlindemo/demoSequences.kt" target="code">demoSequences.kt</a>  (project <m><ks>it.unibo.kotlinIntro</ks></m>).
<br/><br/>

<center><table style="width:95%">
<tbody>	
 <tr>
<td style="width:45%">
<pre>
data class APerson(val name: String, val age: Int)

val <ks>persons</ks> = listOf(
    APerson("Peter", 16),
    APerson("Alice", 23),
    APerson("Anna",  25),
    APerson("Anna",  28),
    APerson("Sonya", 39)
)

val names = <ks>persons</ks><k>.asSequence()</k>
    .filter { it.age > 18 }
    .map { it.name }
    .distinct()
    .sorted()
    .toList()

fun testSequence(){
 	println(names)
}
	
fun main(){
    println("BEGINS CPU=$cpus ${curThread()}")
	<m>println( "work done in time= ${measureTimeMillis({testSequence()})}")</m>
    println("ENDS ${curThread()}")
}	
</pre>
</td>
<td>
<h3>Sequences</h3>
<m>are a key abstraction to functional programming in Kotlin, a concept quite similar to <tt>Java 8</tt> <em>Streams</em>.
They represent <bc>lazily evaluated collections</bc>.  
See <a href="https://winterbe.com/posts/2018/07/23/kotlin-sequence-tutorial/" target="web">Kotlin Sequence Tutorial</a>.
<br/><br/>
</m>
<pre>
<kc>//OUTPUT</kc>
BEGINS CPU=8 thread=main | nthreads=1
[Alice, Anna, Sonya]
work done in time= 0
ENDS thread=main | nthreads=1
</pre>
<m>Sequences are <bc>stateless</bc> and they reset after being used.</m>
</td>
</tr>

<tr id="yield">
<td>
<pre>
val fiboSeq = sequence{
    var a = 0
    var b = 1 
    <k>yield(1)</k>   <kc>//first</kc>
    while (true) {
        <k>yield(a + b)</k>   <kc>//next</kc>
        val tmp = a + b
        a = b
        b = tmp
    }
}

fun useFibonacciSeq(){
   val v = <k>fibonacciSeq.elementAt(2)</k>
    println("element at 2=$v")
    val firstNums = <k>fibonacciSeq.take(5)</k>  <kc>//calculated later</kc> 
    println("firstNums=${firstNums}")
    println("firstNums=${<k>firstNums.joinToString()</k>}")	
}

fun testSequence(){
 	useFibonacciSeq()
}
fun main(){
    println("BEGINS CPU=$cpus ${curThread()}")
	<m>println( "work done in time= ${measureTimeMillis({testSequence()})}")</m>
    println("ENDS ${curThread()}")
}
</pre> 
</td>

<td>
<h3>Suspendable Sequences</h3>
<m>A <em>suspend function</em> can suspend its execution while waiting for the execution of one or more computations to happen.
<br/><br/>
Instead, a <em>suspendable sequence</em> is a coroutine builder that can suspend between invocation by using the <bc>yield()</bc> function.
<br/>
</m>
<pre>
<kc>//OUTPUT</kc>
BEGINS CPU=8 thread=main | nthreads=1
element at 2=2
firstNums=kotlin.sequences.TakeSequence@28ba21f3
firstNums=1, 1, 2, 3, 5
work done in time= 13
ENDS thread=main | nthreads=1</pre>


</m> 
</td>
</tr> 

</tbody>	
</table></center>

 
<h2><a id="classes"/>Classes and Objects in Kotlin</h2>
The examples hereunder are reported in  <a href="../src/kotlindemo/demoClasses.kt" target="code">demoClasses.kt</a>  (project <m><ks>it.unibo.kotlinIntro</ks></m>).
<br/><br/>

<center><table style="width:95%">
<tbody>	
<tr>
<td>

<h3>Java static</h3>
Let us introduce a static class in Java:
<pre>
public class SingleCounter {
    private <k>static</k> int counter = 0;
    public <k>static</k> int value(){ return counter;}
    public <k>static</k> void inc(){ counter++ ;}
    public <k>static</k> void dec(){ counter-- ;}
    public <k>static</k> void reset(){ counter = 0 ;}
}
</pre> 
</td>
<td>
<h3  id="kotlinObject">Java to Kotlin: object </h3>
The equivalent in Kotlin is:
<pre>
<k>object</k> <ks>SingleCounter</ks> {
    private var counter = 0
    fun value(): Int { return counter }
    fun inc() { counter++ }
    fun dec() { counter-- }
    fun reset() { counter = 0 }
}
</pre>
<m>The conversion form Java to Kotlin can be done automatically by using
<a href="https://www.jetbrains.com/idea/" target="web">IntelliJ IDEA</a> </m>
<br/><br/>
<m><bc>Object</bc>: defines a singleton object. No constructor allowed. Instance created immediately. </m> </td>
</tr>

<tr>
<td><h3>Using Kotlin Object</h3>
<pre>
fun p2( c:<ks>SingleCounter</ks> ) : Int { 
	return c.value()*c.value() }

fun testObject(){
    val c = <ks>SingleCounter</ks>
    val d = <ks>SingleCounter</ks>
    for( i in 1..3 ) c.inc()
    val v = p2( <ks>SingleCounter</ks> )
    println("testObject | 
	 c=${<k>c.value()</k>} d=${<k>d.value()</k>} 
	 obj=${<k><ks>SingleCounter</ks>.value()</k>} v=$v")
    <k><ks>SingleCounter</ks>.reset()</k>
    println("testObject | 
	  c=${<k>c.value()</k>} d=${<k>d.value()</k>} 
	  obj=${<k><ks>SingleCounter</ks>.value()</k>}")	
}

fun main(){
    println("BEGINS CPU=$cpus ${curThread()}")
    println( "work done in time= ${measureTimeMillis({testObject()})}")	
    println("ENDS ${curThread()}")
}
</pre> </td>
<td>
<m>An object is singleton without state; it can be used as a regular object</m>
<pre>
<bc>//OUPUT</bc>
BEGINS CPU=4 thread=main | nthreads=1
testObject | c=3 d=3 obj=3 v=9
testObject | c=0 d=0 obj=0
work done in time= 0
ENDS thread=main | nthreads=1
</pre>
 </td>
</tr>



<tr>
<td style="width:45%"> 
<h3>Java class</h3>
Let us introduce a conventional class in Java:
<pre>
public class Person {
    private final String name;			<kc>//Java field</kc>
    private int age=0;				<kc>//Java field</kc>
    private boolean isMarried = false;	<kc>//Java field</kc>
    public Person(String name){ this.name = name; }
    public String getName(){ return name;  }
    public int getAge(){ return age;  }
    public void incAge(){ age++;  }
    public boolean getIsMarried(){ return isMarried;  }
    public void setIsMarried(boolean v){ isMarried=v;  }
}
<kc>
------------------------------------------------------------
KOTLIN syntax for properties
------------------------------------------------------------</kc>
<ks>var &lt;propertyName>[: &lt;PropertyType>] 
				[= &lt;property_initializer>]
    [&lt;getter>]
    [&lt;setter>]
</ks>
The initializer, getter and setter are optional.
</pre> 

</td>
<td><h3 id="kotlinclass">Java to Kotlin: class </h3>

<m>The result of automatic conversion done by the <a href="https://www.jetbrains.com/idea/" target="web">IntelliJ IDEA</a> is:</m>
<center><img src="./img/PersonKotlin.png" alt="PersonKotlin" width="100%" ></center>

<h3>Kotlin properties</h3>
<m>While Java stores class data into <em>fields</em>, classes in Kotlin do introduce <em>properties</em> 
(<tt>fields</tt> together with <tt>accessors</tt> methods) as a first-class language feature 
(see <a href="https://kotlinlang.org/docs/reference/properties.html" target="web">Kotlin Properties and Fields</a>). 
Note that:
<ul>
<li>properties that stores a value</li>
<li>properties with <bc>custom accessors</bc> that calculates values at each access</li>
<li>Properties are defined by their accessors. A property does not need to include any field at all. </li>
<li>When we define custom accessors that are not using any field, then the field is not generated.
This is why we can use 
<a href="https://kotlinlang.org/docs/reference/delegated-properties.html" target="web"><bc>property delegation</bc></a>.
</li>
</ul></m>
</td>
</tr>



<tr>
<td><h3 id="kotlinclassuse">Using Kotlin Class</h3>
<pre>
<k>class</k> Person(val name: String) { <kc>//Primary constructor</kc>
    var age : Int = 0     		<kc>//Kotlin property</kc>
       <k>set</k>( value ){
	      if(value < 0) println("ERROR: age value wrong")
		  else field = value	<bc>//backing field</bc>
      }
   var married = false   		<kc>//Kotlin property</kc>
      <k>set</k>( value ){
      if(value && age < 14) println("WARNING:too young for marriage")
		<kc>//else married = value  //WRONG!! Stack overflow</kc>
		else <k>field =</k> value
      }
   val isAdult: Boolean
      <k>get</k>(){ return age >= 18}	<kc>//custom getter</kc>
}

fun testClass(){
	println("------ testClass ")
    val p1 = Person("Bob")		 <kc>//no new</kc>
    p1.age=20
    println( "name=${p1.name}, age=${p1.age}, "+
  	  " married=${p1.married} adult=${p1.isAdult} ")
    val p2 = Person("Alice")	<kc>//no new</kc>
    p2.age = 15
    println( "name=${p2.name}, age=${p2.age}, " +
	" married=${p2.married} adult=${p2.isAdult} ")
    val p3 = Person("Bob")
    p3.age= p1.age
    println( "equals:  ${p1.equals(p3)}" )	<kc>//false</kc>
    println( "==:      ${p1 == p3}" )		<kc>//false</kc>
    println( "===:     ${p1 === p3}" )		<kc>//false</kc>
}

fun main(){
    println("BEGINS CPU=$cpus ${curThread()}")
    println( "work done in time= ${measureTimeMillis({testClass()})}")	
    println("ENDS ${curThread()}")
}
</pre> </td>
<td>
<h3>Rules</h3>
<ul>
<li>Classes in Kotlin <b>cannot have static members</b>.</li>
<li>A <a href="https://www.tutorialspoint.com/kotlin/kotlin_constructors.htm" target="web"><bc>Primary constructor</bc></a>
	<ul>
	<li>specifies constructor parameters</li>
	<li>defines properties initialized by those parameters</li>
	</ul>
	</li>
<li>Custom <a href="http://kotlin-quick-reference.com/101-R-getter-setter-properties.html" target="web"><bc> getter accessors</bc></a>
: allows us to implement a computed property </li>
<li>Custom <a href="http://kotlin-quick-reference.com/101-R-getter-setter-properties.html" target="web"><bc> setter accessors</bc></a>
: it is called every time we assign a value to the property.</li>
</ul>
 
<pre>
<kc>//OUTPUT</kc>
BEGINS CPU=4 thread=main | nthreads=1
name=Bob, age=20,  married=false adult=true 
name=Alice, age=15,  married=false adult=false 
equals:  false
==:      false
===:     false
work done in time= 2
ENDS thread=main | nthreads=1
</pre>

<h3 id="backingfield">Backing field</h3>
<ul>
<li>Fields cannot be declared directly in Kotlin classes.
<m>However, when a property needs a backing field, Kotlin provides it automatically.</m></li>
<li>A <em>backing field</em>  is a field <i>generated</i> by the compiler <m>if we reference it explicitly 
or if we use the default accessor implementation.</m>
</li>
<li>The special identifier <bc>field</bc> is used to access the backing field.</li>
</ul>
 

 

</td>
</tr>

<tr>
<td>
<h3 id="propdeleg"><a href="https://kotlinlang.org/docs/reference/delegated-properties.html" target="web"><k>Property delegation</k></a></h3>
<pre>
class ExampleDelegate {
    var p: String  <k>by</k> <ks>Delegate</ks>()  <kc>//delegated property</kc>
}
class <ks>Delegate</ks> {
	private var <ks>myval</ks> : String = "delegateInitialValue"
    opercoator fun <k>getValue</k>(
			thisRef: Any?, property: KProperty<*>): String {
	   println("... object $thisRef delegates '${property.name}' to $this!")
	   return <ks>myval</ks>
    } 
    operator fun <k>setValue</k>(
			thisRef: Any?, property: KProperty<*>, value: String) {
	   println("... $this assigns $value to '${property.name}' in $thisRef.")
	  <ks> myval = value</ks>
    }
}

fun testPropertyDelegate(){
	val v = ExampleDelegate()
	println(v.p)
	v.p = "Bob"
	println(v.p)
}

fun main() = runBlocking{
    println("BEGINS CPU=$cpus ${curThread()}")
    println( "work done in time= 
		${measureTimeMillis(  { testPropertyDelegate() } )}"  )
	println("ENDS ${curThread()}")
}
</pre>
 

</td>
<td>
<pre>
<kc>//OUTPUT</kc>
BEGINS CPU=8 thread=main | nthreads=1
<m>... object kotlindemo.ExampleDelegate@1175e2db delegates 'p' to kotlindemo.Delegate@36aa7bc2!</m>
delagteDefaultValue
<m>... kotlindemo.Delegate@36aa7bc2 assigns Bob to 'p' in kotlindemo.ExampleDelegate@1175e2db.
... object kotlindemo.ExampleDelegate@1175e2db delegates 'p' to kotlindemo.Delegate@36aa7bc2!</m>
Bob
work done in time= 44
ENDS thread=main | nthreads=1

</pre>

<h3>Java equivalent of a Kotlin property</h3>
<pre>
private String name = "Bob";
public String getName() { return name; }
public void setName(String name) { this.name = name; }
</pre>
</td>
</tr>

<tr>
<td><h3 id="dataclass">Kotlin data class</h3>
<pre>
<k>data class</k> PersonData(val name: String) { <kc>//Primary constructor</kc>
    var age : Int = 0     		<kc>//public</kc>
    var married = false   		<kc>//public</kc>
    val isAdult: Boolean
      get(){ return age >= 18}	<kc>//custom getter</kc>
}

fun main(){
    val p1 = PersonData("Bob")
    p1.age=20
    val p3 = PersonData("Bob")
    p3.age = p1.age
    println( "p1=${p1}, p3=$p3")		<kc>//<ks>toString</ks> generated</kc>
    println( "equals:  ${<k>p1.equals</k>(p3)}" )	<kc>//<ks>equals</ks> generated</kc>
}
</pre> </td>
<td>
Kotlin generates the methods:
<ul>
<li><bc>equals</bc></li>
<li><bc>hasCode</bc></li>
<li><bc>toString</bc></li>
</ul>

</m> 
<pre>
<kc>//OUTPUT</kc>
BEGINS CPU=4 thread=main | nthreads=1
p1=PersonData(name=Bob), p3=PersonData(name=Bob) 
equals:  true
work done in time= 1
ENDS thread=main | nthreads=1
</pre>
</td>
</tr>

 

<tr>
<td>
<h3 id="companionobj">Companion object</h3>
<pre>
class PersonCO <k>private constructor</k>( val name: String ){
    var age : Int = 0
    var married = false
    val isAdult: Boolean
        get(){ return age >= 18} <kc>//custom getter</kc>
  
	<k>companion object</k> {
		val <ks>personList</ks> = mutableListOf&lt;PersonCO>()
		fun <ks>createPerson</ks>( name: String ) : PersonCO {
			val p = PersonCO( name.toUpperCase() )
			personList.add(p)
			return p
		}
		fun <ks>showAllPersons</ks>(){
		personList.forEach {
			println( "name=${it.name}, age=${it.age},
				married=${it.married} ") }
		}
	}<kc>//companion</kc>
	
	<k>object  Info</k> {
		fun <ks>showAllAdults</ks>(){
			personList.forEach {
				if( it.isAdult )
				println( "ADULT ${it.name} of age=${it.age}  ") }
		}
		fun <ks>showOrderedByName</ks>(){
			println( <ks>personList</ks>.sortedWith(<k>NameComparator</k>))
		}
	}<kc>//Info</kc>
    
	<k>object NameComparator</k><ks>:Comparator&lt;PersonCO></ks>{<kc>//Interface</kc>
		<k>override</k> fun <ks>compare</ks>(p1:PersonCO, p2:PersonCO):Int =
				p1.name.compareTo(p2.name)
	}<kc>//NameComparator</kc>
	
}<kc>>//PersonCO</kc>


fun testCompanion(){
    <kc>//</kc>val <ks>p = PersonCO("Bob")</ks> <kc>//ERROR: init is private in PersonCO</kc>
    val p1 = <k>PersonCO.createPerson</k>("Bob")
    p1.age=20
    val p2 = /k>PersonCO.createPerson</k>("Alice")
    p2.age = 15
    <k>PersonCO.createPerson</k>("Adam")		<kc>//age=0</kc>
    <k>PersonCO.showAllPersons</k>()
    <k>PersonCO.Info.showAllAdults</k>()	
}

fun main(){
    println("BEGINS CPU=$cpus ${curThread()}")
    println( "work done in time= ${measureTimeMillis({testCompanion()})}")
    println("ENDS ${curThread()}")
}
</pre> </td>
<td>
<h3>Rules (See <a href="https://kotlinlang.org/docs/tutorials/kotlin-for-py/objects-and-companion-objects.html" target="web">Objects and companion objects</a>)</h3>

<ul>
<li><bc>Primary constructor private</bc>: the class cannot be instantiated.</li>
<li><bc>Companion object</bc>: a singleton declared within a class that can access to the private members of the class.
<br/><m>The properties and methods of a <tt>Companion object</tt> can be accessed through the name of the containing class,
without specifying the name of the object explicitly. 
<br/>However, we can also insert the name of the companion object.</m>
</li>
<li>The resulting syntax looks like <em>static method</em> invocation in Java.</li>
<li>A (singleton) <bc>Object</bc> can be declared into a class.</li>

</ul>
 
<pre>
<kc>//OUTPUT</kc>
BEGINS CPU=4 thread=main | nthreads=1
name=BOB, age=20,married=false 
name=ALICE, age=15,married=false 
name=ADAM, age=0,married=false 
ADULT BOB of age=20  
work done in time= 4
ENDS thread=main | nthreads=1
</pre>
 </td>
</tr>
 

<tr>
<td>
<h3 id="enumclass"><a href="https://kotlinlang.org/docs/reference/enum-classes.html">Enum Classes</a></h3>
<pre>
enum class <ks>Color</ks>(var r: Int, val g: Int, val b: Int){ <kc>//properties</kc>
<kc>//Property values for each constant</kc>
	RED(255,0,0) <k>,</k> 
	YELLOW(255,255,0) <kc>//declares its own anonymous class</kc>
	{<k>override</k> fun toString():String{ return "YELLOW_COLOR"} } <k>,</k> 
	GREEN(0,255,0) <k>,</k> 
	BLUE(0,0, 255)
    <k>;</k> <kc>//semicolon is is mandatory if define methods</kc>

	fun rgb() = (r * 256 + g) * 256 + b
	<k>override</k> fun toString():String{return "${<k>super.</k>toString()}($r,$g,$b)"}
}

fun main(){
    val y = <ks>Color</ks>.YELLOW
    val b = <ks>Color</ks>.BLUE
    println("$y = ${y.rgb()} | $b = ${b.rgb()} ")
}
</pre> </td>
<td><m><em>enum</em>: is a <bc>soft keyword</bc> (i.e. the name can be reused) 
that introduces a set of constant objects, each instance of the class.
Each object can be initalized and declare methods.</m> 

<pre>
<kc>//OUTPUT</kc>
BEGINS CPU=8 thread=main | nthreads=1
YELLOW_COLOR = 16776960 | BLUE(0,0,255) = 255 
work done in time= 5
ENDS thread=main | nthreads=1

</pre>
 

<br/><br/></td>
</tr>

<tr>
<td><h3 id="ill">About initialization</h3>
<pre>
<k>enum</k> class <ks>Origin</ks>{
    asia, africa, europa, america, australia
}

<kc>//open: see Inheritance</kc>
<k>open class</k> PersonILL(val name:String,	<kc>//ILL=>Init,Late,Lazy</kc>
		val nickname: String = "rambo") {<kc>//default value</kc>
    var age      = 0
    var married   = false
    val isAdult: Boolean <k>by lazy</k>{ println("lazy fired");age>18 }
    <k>lateinit var</k> country  : Origin  <kc>//visible</kc>
    protected var  voter  : Boolean 	<kc>//not visible</kc>
        get(){ return isAdult }
    <k>init{</k> <kc>//country = Origin.europa</kc>
        voter  =  (age > 18)   <kc>//expression</kc>
    }
    <kc>//custom accessor</kc>
    fun voter():Boolean{ return voter }
}

fun testILL(){
 val p = PersonILL("Bob")
  println("name=${p.name} age=${p.age} married=${p.married} " +
     " nickname=${p.nickname}  ") // p.country not initialized
  p.age     = 22
  p.married = true
  p.country = Origin.europa
  println("Bob property-set done ")
  println("Bob is adult=${p.isAdult} - lazy fired")  
  println("name=${p.name} age=${p.age} married=${p.married}")
  println("	adult=${p.isAdult} nickname=${p.nickname}")
  println("	country=${p.country} voter=${p.voter()}")	
}
 
fun main(){
	println("BEGINS CPU=$cpus ${curThread()}")
	println( "work done in time= ${measureTimeMillis({testILL()})}")	
	println("ENDS ${curThread()}")
}
</pre>
<hr/>
<pre><kc>//OUTPUT</kc>
Bob property-set done 
<ks>lazy fired</ks>
Bob is adult=true - lazy fired
name=Bob age=22 married=true
	adult=true nickname=rambo
	country=europa voter=true  <kc>//no more lazy fired</kc>
work done in time= 46
ENDS thread=main | nthreads=1
</pre> </td>
<td> 


<h3>default parameter values</h3>
set default values for properties. Their usage avoids the introduction of secondary constructors
<br/><br/>
<h3>init block</h3>

 <em>init</em> is a keyword that introduces an 
<a href="https://www.callicoder.com/kotlin-classes-objects-constructors-initializers/"><bc>initializer block</bc></a>
 

<br/><br/>

<h3>lateinit</h3>
 a modifier that allows us to introduce a <bc>var</bc> property without an initializer.
It is not applicable to primitive types. 

<br/><br/>
A common use is for <a href="https://it.wikipedia.org/wiki/Dependency_injection" target="web">dependency injection</a>.
 
<h3>lazy</h3> 
variable will not be initialized unless you use that variable in your code. 
It will be initialized <em>only once</em> after that we always use the same value.

<h3>Guidelines</h3>
<ul>
<li>If variable are mutable (i.e. might change at a later stage) use <bc>lateinit</bc>.<br/>
 <bc>lateinit var</bc> can be initialized from anywhere the object is seen from.</li>
<li><bc>lazy</bc> can only be used for <bc>val</bc> properties,<m> whereas lateinit can only be applied to var because 
it can't be compiled to a final field, thus no immutability can be guaranteed.</m></li>
<li>If its only meant to initialized once and shared by all, and it's more internally set 
(dependent on variable internal to the class), then use <bc>lazy</bc>. </li>
</ul>

</td>
</tr>

<tr>
<td>
<h3 id="inheritance">Inheritance</h3>
<pre>
<k>open class</k> PersonILL(val name:String, ...

class <ks>Student</ks>(name: String,
	nickname: String="nerd") <k>: Person(name, nickname)</k> {
	override fun toString() : String{
		return "student(name($name),age($age),married($married),"+
		"adult($isAdult),nickname($nickname),"+
		"country($country),voter($voter))" 
	}
}

fun testInheritance(){
  val p = <ks>Student</ks>("alice", "batterfly")
  p.age		= 24
  p.country	= Origin.asia
  println( p )
}

fun main(){
	println("BEGINS CPU=$cpus ${curThread()}")
	println( "work done in time= ${measureTimeMillis({testInheritance()})}")	
	println("ENDS ${curThread()}")
}

</pre> </td>
<td>

 <bc>open</bc>: a modifier that makes it possible to define subclasses.
 <br/><br/>
Whereas Java's classes and methods are open by default, in Kotlin they are <bc>final</bc>,
in order to overcome the <a href="https://en.wikipedia.org/wiki/Fragile_base_class" target="web">fragile base class problem</a>.

<pre>
<kc>//OUTPUT</kc>
BEGINS CPU=8 thread=main | nthreads=1
lazy fired
<m>student(name(alice),age(24),married(false),adult(true),nickname(batterfly),country(asia),voter(true))</m>
work done in time= 47
ENDS thread=main | nthreads=1
</pre>
<h3>Abstract classes</h3>

An <em>abstract</em> class is <bc>open</bc> by default.
<br/><br/>
Abstract classes can have everything that interfaces can, and additionally, 
they can have fields and constructors. 
Therefore we can properly hold state in abstract classes 


</td>
</tr>

<tr>
<td>
<h3 id="sealedclass">Sealed class</h3>
<pre>
<k>sealed class</k> <ks>Expr</ks>{
    <k>class</k> <ks>Num</ks>( val value:Int):Expr()
    <k>class</k> <ks>Add</ks>( val left:Expr, val right:Expr):Expr()
    fun eval():Int{
        when( <k>this</k> ){
            <k>is Num</k> -> return value
            <k>is Add</k> -> return left.eval() + right.eval()
            <kc>//no deafult branch</kc>
        }
    }
}

fun testSealedClass(){
    val v1 = Expr.Num(10)
    val v2 = Expr.Num(20)
    val sum = Expr.Add(v1,v2)
    println("${v1.eval()} + ${v2.eval()} = ${sum.eval()}")	
}

fun main(){
	println("BEGINS CPU=$cpus ${curThread()}")
	println( "work done in time= ${measureTimeMillis({testSealedClass()})}")	
	println("ENDS ${curThread()}")
}
</pre> </td>
<td>
<bc>sealed </bc>: a modifier which restricts the possible subclasses of a class. All the possible subclasses
must be nested in the superclass.

<pre>
<kc>//OUTPUT</kc>
BEGINS CPU=8 thread=main | nthreads=1
10 + 20 = 30
work done in time= 7
ENDS thread=main | nthreads=1

</pre>
</td>
</tr>

<tr>
<td><pre></pre> </td>
<td><m><em> </em></m> </td>
</tr>

</tbody>	
</table></center>

<br/><br/> 
</div>  
<div style="background-color:rgba(86, 56, 253, 0.9); width:100%;text-align:center;font-size:small;color:white">
By AN Unibo-DISI    
</div> 
</body>
</html>

<!--
class CounterMsg( 
	val cmd:String, val replyChannel:SendChannel<Int>?=null){
}

fun counterActor() : SendChannel<CounterMsg> = GlobalScope.actor<CounterMsg> {
    var localCounter = 0 // actor state
    for (msg in channel) { // iterate over messages
        when ( msg.cmd ) {
            "INC" -> localCounter++
            "DEC" -> localCounter--
            "GET" -> msg.replyChannel?.send(localCounter)
            else -> throw Exception( "unknown" )
        }    }
}

suspend fun useTheCounter(){
    val counter = counterActor()
    println("INC")
    counter.send( CounterMsg("INC") )

    val answerChannel = Channel<Int>()
    counter.send( CounterMsg("GET", answerChannel) )

    val answer = answerChannel.receive()
    println("useTheCounter COUNTER = $answer")
}

fun main() = runBlocking{
    println("BEGINS")
    useTheCounter()
    println("ENDS")
}

//OUTPUT
BEGINS with 4  cores
INC
useTheCounter COUNTER = 1
ENDS 
-->