<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
    <!--
<link rel="stylesheet" type="text/css" href="../css/issStyle1.css">
<script type="text/javascript" src="../css/issStyle.js"></script>
-->
<style type="text/css">
body
{
    margin-left:  30px;
    margin-right: 30px;
};

P
{
    font-family: Tahoma;
    font-size: 10pt;
};

a, a:visited, a:active, a:link, a:hover {
    text-decoration: underline;
    color: #545454;
    background-color: transparent;
}

a:hover {
    background-color: #cccccc;
}


hr {
    clear: both;
    height: 1px;
    color: #242424;
    background-color: transparent;
}

h1, h2, h3 {
    color: #242424;
    clear: left;
    font: 100% Tahoma, Helvetica, Arial, sans-serif;
    margin: 10;
    margin-right: 15px;
    margin-bottom: 0.5em;
    padding-top: 0.5em;
    border-bottom: 1px solid #242424;
}

h1 {
    font-size: 150%;
    background-color: #b2c0ff;
}

h2 {
    background-color: #d9fbff;
    font-size: 110%;
}

h3 {
	background-color: #e6ccff;
    font-size: 80%;
}
h4 {
    background-color: #99ffcc;
    font-size: 100%;
	width: 750px;
}
#i {
    color: #ff1010;
}
tt{
	font-family: "Arial";
    font-size: 80%;
	color: #006600;
}
em{
	font-family: "Arial";
    font-size: 80%;
	font-weight: bold;
	border-style:solid;
	border-color: #ccffff;
    color: #0033cc;
}
bc{
	font-family: "Arial";
	font-size: 80%;
	font-weight: bold;
    color: #990000;
	background-color: #fcf8c7;
}
k{
	font-family: "Arial";
	font-weight: bold;
    color: #990000;
	 
}
ks{
	font-family: "Arial";
	font-weight: bold;
    color: #0000CD	;
	 
}
kc{
	font-family: "Arial";
	font-weight: bold;
    color: #008000	;
	 
}
pre{
	font-family: "Helvetica";
	font-size: 70%;
	background-color: #fcf8c7; 
}
 
m{
	font-family: "Helvetica";
	line-height: 100%;
 	font-size: 75%;
}
div.body{
	width: 800px;
    font-size: 18px;
}    
div.req{
	background-color: #d9ffb3;
    font-size: 18px;
	width: 700px;
    border: 3px solid green;
    padding: 15px;
    margin: 10px;
}    

div.remark{
	background-color: #FFFC33;     
    border: 3px solid green;
    padding: 15px;
    margin: 10px;
}  

table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}
</style>
    
<head>
   
<title>LABKotlinIntroISS</title></head>
    
<body>

<div class="body"> 


<div id="top">
<h1>LabKotlin | Introduction to <a href="https://kotlinlang.org/" target="web">KOTLIN</a></h1> 

<a href="http://htmlpreview.github.com/?https://github.com/anatali/iss2020LabBo/blob/master/it.unibo.issLabStart/userDocs/LectureBologna1920.html" 
target="isslm">LabISS-lectures site</a></font> 
</div> 
<h2><a id="basics"/>OVERVIEW</h2>

<ol>
<li>Basic elements of any computation are data and <bc>functions</bc> (data can be also viewed as functions that return values). </li>
<li>Functions are <bc>first class objects</bc> that have a type, can be assigned to variables and used as function arguments or as
return values.</li>
<li>Computations almost always require the usage of <bc>threads</bc> and to face concurrency problems, even in <tt>multi-core</tt> environments.</li>
<li><bc>Lexical Closures</bc> are often used as callbacks in <bc>asynchronous</bc> (IO-bound) programming according to a Continuation Passing Style (<bc>CPS</bc>)</li>
<li>The single-threaded <tt>event-loop model</tt> of <ks>Node.js</ks> (JavaScript) leads to the idea of message/job queue.</li>
<li>On May 2019, Google announced that the 
<a href="https://en.wikipedia.org/wiki/Kotlin_(programming_language)" target="web">Kotlin programming language</a>
 is now its preferred language for Android app developers.
 <m>The Android OS is single threaded by default, which means operations will run by default on the UI thread except 
they are explicitly scheduled to run on a background thread. 
The UI thread is responsible for handling UI updates and executing long running operations on this thread can freeze your app, 
or crash the app and show an <ks>ANR</ks> (Application Not Responding) error.</m>
</li>
<li>The Kotlin concept of <bc>coroutine</bc> allows us to introduce thread in a very light way. The concept is based on the idea
of suspend a  computation without blocking a thread (<bc>suspend function</bc>) implemented using (under the hoods) a state machine 
and <tt>CPS</tt>. </li>
<li>Kotlin <bc>channels</bc> promote interaction among coroutines in term of <tt>stream of values</tt>.</li>
<li>Kotlin <bc>actors</bc> promote a <tt>message-based programming style</tt> that overcomes traditional procedure-call interaction without
loosing in performance.</li>
</ol>

 
 <table style="width:95%">
<tbody>	
<tr>
<td style="width:55%">
<h3 id="index">INDEX</h3>

<ol>
<li><a href="#data">Data, Types and Variables</a></li>
<li><a href="#funs">Functions</a></li>
<li><a href="#lambda">Using lambda</a></li>
<li><a href="#clos">Closures and Callbacks</a></li>
<li><a href="#coroutinesIntro">Introduction to coroutines</a></li>  
<li><a href="#suspend">Suspending functions</a></li>
<!-- <li><a href="#dispatch">Dispatchers</a></li> 
<li><a href="#concur">Concurrency</a></li> -->
<li><a href="#channels">Channels</a></li>
<li><a href="#kotlinprodcons">Producers-consumers in Kotlin</a></li>
<li><a href="#actors">Kotlin Actors</a></li>
<!--
<li><a href="#sequence">Sequences (suspendable)</a></li>
<li><a href="#classes">Classes</a></li>
-->
 
  
</ol>
</td>

<td style="width:45%">
<img src="./img/KotlinInAction.png" alt="KotlinInAction" width="70%" height="40%">
 
</td>

</tr> 
</tbody>	
</table>
 
 
 
To run the <a href="https://kotlinlang.org/" target="web">KOTLIN</a> experiments, 
use an IDE or <a href="https://play.kotlinlang.org" target="web">Kotlin Playground</a>.

You can consult also: <a href="https://try.kotlinlang.org/#/Examples" target="web">Kotlin online</a>
<br/> <br/> 

For the examples hereunder, look at <a href="../src/kotlindemo/demoBasic.kt" target="code">demoBasic.kt</a>  (project <m><ks>it.unibo.kotlinIntro</ks></m>).

<h2><a id="data"/>Data, Types and Variables</h2>

<center><table style="width:95%">

<tbody>	
<tr>
<td style="width:45%"><pre> <k>val</k> base : Int = 0</pre> </td>
<td><m><em>Immutable reference</em>. </m> </td>
</tr>

<tr>
<td><pre><k>var</k> counter = 0</pre> </td>
<td><m><em>Mutable reference</em>. The Type <bc>Int</bc> is inferred</m> </td>
</tr>

<tr>
<td><pre>val name = "Bob"
val st   ="hello<k>$</k>name"
<kc>------</kc>
println( st )	//Hello Bob
</pre> </td>
<td><m><em>String template</em></m> </td>
</tr>


<tr>
<td><pre>val data : String<k>?</k> = null
val v = data<k>?</k>.length ?: 0
<kc>------</kc>
println("v=$v")	//0
</pre> </td>
<td><m><em>Nullable type</em> with safe null access</m> </td>
</tr>
<tr>
<td><pre>
val v01 : <k>Any</k> = 23
<kc>------</kc>
println( "v01 is String=${v01 </k>is</k> String}") //false
println( "v01 is Int=${v01 <k>is</k> Int}")	//true
</pre> </td>
<td><m><em>Type hierarchy</em>. <bc>Any</bc> is is a non-nullable type that denotes the root of the Kotlin class hierarchy. <br/>
<bc>Unit</bc> is used as a return type of a function that has nothing to return.<br/>
 <bc>is</bc> is a predefined check operator (like Java <bc>instanceOf</bc>)
</m> </td>
</tr>


<tr>
<td><pre>
val v02  : Any = "Bob"
val sv02 = v02 is String
val nv02 = v02 is Int
<kc>------</kc>
println( "v02 is String=${sv02}") //true
println( "v02 is Int=${nv02}")	//false
<k>if (v02 is String)</k> print(v02.length)
</pre> </td>
<td><m><em>Smart cast</em>.  The compiler tracks the is-checks (and explicit casts) for immutable values and inserts 
(safe) casts automatically when needed.</m> 
</td>
</tr>

<tr>
<td><pre>//val n = v02.length 		<kc>//ERROR</kc>
val n02 = (v02 <k>as</k> String).length
<kc>------</kc>
println( "$n02")              <kc> //3</kc>

println( "${v02 as Int}") <kc>//java.lang.ClassCastException</kc>

println( "${v02 <k>as?</k> Int}")  	<kc>//null</kc>
val t : Int = v02 as? Int <k>?:</k> 100
<kc>------</kc>
println( "$t") 				<kc>//100</kc>
</pre> </td>
<td><m><em>Explicit casting</em>.<br/>
 The <bc>as</bc> operator performs type casting. <br/><br/>
The <bc>as?</bc> operator performs safe type casting.<br/><br/>
The <bc>?:</bc> is the <em>Elvis operator</em> that provides default values instead of null.
</m> </td>
</tr>

<tr>
<td ><pre>
val s1 = "a"
var s2 = "a"
<kc>------</kc>
println( "s1 === s2 : ${s1 <k>===</k> s2} ") 	<kc>//true</kc>
println( "s1 == s2  : ${s1 <k>==</k> s2} ")	<kc>//true</kc>

s2 = "b"
<kc>------</kc>
println( "s1 === s2 : ${s1 === s2} ") 	<kc>//false</kc>
s2 = "a"
<kc>------</kc>
println( "s1 === s2 : ${s1 === s2} ")	<kc>//true</kc>

val fa = java.io.File("a")
val fb = java.io.File("a")
<kc>------</kc>
println( "fa === fb : ${fa === fb}")	<kc>//false</kc>
println( "fa == fb  : ${fa == fb}")		<kc>//true</kc>

</pre> </td>
<td><m><em>Referential equality</em> <bc>===</bc> <br/>
<em>Structural equality</em> <bc>==</bc> 
(translated into a call of the <bc>equals</bc> function of the class) </td>
</tr>

<tr>
<td><pre> 
val aToz = "a"<k>..</k>"z"
val q = "q"
<kc>------</kc>
println( "q in aToz=${q <k>in</k> aToz}")				<kc>//true</kc>
println( "1 in aToz=${<k>"""</k>1<k>"""</k> in aToz}") 	<kc>//false</kc>
</pre> </td>
<td><m><em>Range</em> created by the <bc>..</bc> operator.
The <bc>in</bc> infix operator performs a belong test. Triple quotes <bc>"""</bc> do not require escaping chars</m></td>
</tr>

<tr>
<td><pre>
var arr = <k>arrayOf</k>(1,2,3)
<kc>------</kc>
println( "arr size=${arr.size}")
println( "firstEl=${arr[0]}  lastEl=${arr[arr.size-1]}")
</pre> </td>
<td><m><em>Array</em>. They are a regular collection class. <bc>size</bc> is a 
<a href="https://kotlinlang.org/docs/reference/properties.html" target="code"><em>Property</em></a>
</m> </td>
</tr>


</tbody>	
</table></center>

<br/><br/> 	
 
<h3>Utility functions</h3>
For the examples hereunder, start from <a href="../src/kotlindemo/demoTemplate.kt" target="code">demoTemplate.kt</a>  (project <m><ks>it.unibo.kotlinIntro</ks></m>)
that introduces:

<pre>
val <k>cpus</k> = Runtime.getRuntime().availableProcessors();

fun <k>curThread()</k> : String { 
	return "thread=${Thread.currentThread().name} / nthreads=${Thread.activeCount()}" 
}

inline fun <k>measureTimeMillis</k>(block: () -> Unit): Long {
    val start = System.currentTimeMillis()
    block()
    return System.currentTimeMillis() - start
}
</pre>

<h2><a id="funs"/>Functions </h2>

These examples are reported in  <a href="../src/kotlindemo/demoFun.kt" target="code">demoFun.kt</a>  (project <m><ks>it.unibo.kotlinIntro</ks></m>).
<br/><br/>
 

<center><table style="width:95%">
<tbody>	
<tr>
<td style="width:45%"><pre>
fun <k>fsum(a:Int, b:Int) : Int</k> {
  return a+b
}
<kc>------</kc>
println( " ${fsum(3,6)} " ) 	<kc>//9</kc>
</pre> </td>
<td><m>A <em>Top-level function</em> that returns a value.<br/>

<center><img src="./img/fun0.png" alt="fun0.png" width="50%"/></center>
 
 </m>
 </td>
</tr>

<tr>
<td><pre>var fcounter = 0
fun <k>incCounter() : Unit</k>{ fcounter++ }
fun <k>decCounter()</k> { fcounter-- }
<kc>------</kc>
println( "pre=$fcounter  " ) 	<kc>//pre=0</kc>
incCounter()
println( "post=$fcounter " ) 	<kc>//post=1</kc>
</pre> </td>
<td><m>Top-level functions that <em>do not </em> return a value. The return type <bc>Unit</bc> can be omitted</m><br/>

<center><img src="./img/funUnit.png" alt="funUnit.png" width="40%"/></center>
</td>
</tr>

<tr>

<tr>
<td><pre>
fun fsquare<k>(v: Int) = v * v</k>
<kc>------</kc>
println(  fsquare(3)  ) 	<kc>//9</kc>
</pre> </td>
<td><m><em>One line function</em>. Braces can be omitted. Return type can be omitted (it is inferred)</m> </td>
</tr>
 
<td>

<pre>
val ftaction : <k>() -> Unit</k> 	   
	<kc>//function type (no args, returns nothing (Unit)</kc>

val ftsum : <k>( Int,  Int) -> Int </k> 
	<kc>//function type (two args, returns an Int)</kc>

val ft greet: <k>(String )-> <ks>()->Unit</ks></k>
	<kc>//returns another function  </kc>
</td>
<td><m><h3>Function type</h3> is just a syntactic sugar for an interface, but the interface cannot be used explicitly.
We can  use it to type local variables, properties or arguments.
It is implemented in Java as a <bc>FunctionN</bc> interface.
<br/>
A  way to provide a value function is to use a <em>function literal</em>:

<ul>
<li><bc>Lambda expression</bc></li>
<li><bc>Anonymous function</bc></li>

</ul>
</m> </td>
</tr>

<tr>
<td><pre>
<k>ftaction= {</k> println("hello") <k>}</k>  <kc>//lambda expression</kc>
<kc>------</kc>
ftaction() 		<kc>//hello</kc>

<k>ftsum = {</k>  x:Int, y:Int -> x+y <k>}</k>  <kc>//lambda expression</kc>
val fva = ftsum(1,2)
<kc>------</kc>
println("fva=$fva")	      <kc>//fva=3</kc>

<k>ftgreet = {</k>  m: String -> { println(m)}   <k>}</k>
<kc>------</kc>
ftgreet( "Hello World" )() 	<kc>//Hello World</kc>

println( { println( "Welcome" ) } )		<kc>//() -> kotlin.Unit</kc>
println( { println( "Welcome" ) }() )	<kc>//Welcome  kotlin.Unit</kc>


val <k>fel = {</k>  print( "Last exp val:" ); 100  <k>}</k>
<kc>------</kc>
println( "${ <k>fel()</k> }" )  <kc>//Last exp val=100</kc>
</td>
<td><h3>Lambda Expression literal</h3>
<m>it can be assigned to a variable, just like any other literal. <br/><br/>
A call returns (the value of the) <bc>last</bc> expression </m> </td>
</tr>

<tr>
<td>
<pre>
val faction: <k>()-> Unit</k> = <ks>fun()</ks> { println("Hello from faction") }
<kc>------</kc>
faction() 		<kc>//Hello from faction</kc>

val fsquare: <k>(Int)->Int</k>  = <ks>fun(x)</ks> = x * x
<kc>------</kc>
println("fsquare=${fsquare(3)}")	      <kc>//fsquare=9</kc>

val greet: <k>(String)->()->Unit</k> = 
		<ks>fun</ks>(m:String) = <ks>fun()</ks>{ println("Printing $m") }
<kc>------</kc>
println( greet )			<kc>//(kotlin.String) -> () -> kotlin.Unit</kc>
println( greet( "Hello World1" ) )	<kc>//() -> kotlin.Unit</kc>
greet<ks>( "Hello World" )</ks><k>( )</k> 	<kc>//Printing Hello World</kc>

------------------------------------------
fun fexec23( op: <k>(Int, Int) : Int</k> ) : Int  {  <k>return</k> op(2,3)  }

val v23 =  fexec23( <ks>fun(x:Int,y:Int):Int{return x+y}</ks> )
<kc>------</kc>
println("$v23")         					<kc>//5</kc>
println( fexec23( { x:Int, y:Int -> x*y } )	 )	<kc>//6</kc>
</pre> </td>
<td><m><em>Anonymous function</em>; another way to write a block of code instead of a Lambda expression. Needs <bc>return</bc>
like any function </m> </td>
</tr>


</tbody>	
</table></center>


<h2><a id="lambda"/>Using lambda</h2>
Java 8 introduced lambda expressions along with functional interfaces.<br/> 
A <m><k>functional interface</k></m> is an interface with a single method. They are commonly referred to as <i>Single Abstract Method</i> or <m><k>SAM</k></m>.
<br/> 
<m><k>Lambda expressions</k></m> represents these functional interfaces in a more concise way, to deal with functional programming. 
<br/><br/>
The examples hereunder are reported in  <a href="../src/kotlindemo/demoLambda.kt" target="code">demoLambda.kt</a>  (project <m><ks>it.unibo.kotlinIntro</ks></m>).
<br/><br/>

<center><table style="width:95%">
<tbody>	


<tr>
<td><pre>
fun exec23( op:(Int,Int) -> Int ) : Int { return op(2,3) }

val sum = { x:Int, y:Int -> x+y }
val mul = { x:Int, y:Int -> x*y }

println("${ exec23(sum) }")	      <kc>//5</kc>
println("${ exec23(mul) }")	      <kc>//6</kc>

</td>
<td><m><em>Higher order functions</em>. </m> </td>
</tr>



<tr>
<td><pre>
val v1 = exec23( { x:Int, y:Int -> x-y } ) <k>//1) no shortcut</k>
<kc>------</kc>
println("v1=$v1")	      <kc>//v1=-1</kc>

val v2 = exec23<k>()</k> { x:Int, y:Int -> x-y } <k>//2) lambda last arg</k>
<kc>------</kc>
println("v2=$v2")	      <kc>//v2=-1</kc>

val v3 = exec23{ x:Int, y:Int -> x-y } <k>//3) () can be removed</k>
<kc>------</kc>
println("v3=$v3")	      <kc>//v3=-1</kc>

val v4 = exec23{ x,y -> x-y } <k>//4) arg types inferred</k>
<kc>------</kc>
println("v4=$v4")	      <kc>//v4=-1</kc>
</td>
<td><h3>Lambda syntax shortcut</h3> </td>
</tr>

<tr>
<td><pre>
fun p2( op: ( Int ) -> Int ) : Int { return op(2) }

    println( p2( { <k>x:Int-> x*x }</k> ) )	<kc>//4</kc>
    println( p2<k>( )</k>  { x:Int-> x*x } )	<kc>//4</kc>
    println(  p2 { <k>x:Int-> x*x</k> }	)	<kc>//4</kc>
    println(  p2 { <k>x -> x*x</k> } )		<kc>//4</kc>
    println(  p2 { <k>it -> it*it</k> } )		<kc>//4</kc>
    println(  p2 { <k>it*it</k> } )			<kc>//4</kc>
    println( p2{ <k>it * it / 2</k> } )		<kc>//2</kc>
</pre> </td>
<td><h3>Simplification in lambda call</h3>

<pre>
p2 { it*it }
</pre>

<m> The keyword <bc>it</bc> is an auto-generated parameter name </m></td>
</tr>



<td><pre>
fun modulo(k:Int): (Int) -> Int   <k> //SIGNATURE</k>
            = { it % k  }               <k>//BODY</k>	
<kc>------</kc>
println(  modulo(3)(5) ) 	<kc>//2</kc>
println(  modulo(5)(3) ) 	<kc>//3</kc>
</pre> </td>
<td><m><em>Function as return value</em>.  </m> </td>
</tr>




<tr>
<td><pre>
</pre> </td>
<td><m><em></em></m> </td>
</tr>

<tr>
<td><pre>
fun sToN( s: String, base: Int<k>=10</k> ) : Int{
    var v = 0
    for( i <ks>in</ks> 0..s.length-1 ) {
        v = ( s[i].toInt()-48 ) + v*base
    }
    return v
}
<kc>------</kc>
println( " ${ sToN( <k>s=</k>"123") } " ) 	<kc>//123</kc>
</pre> </td>
<td><m><em>Default parameters</em> and <em>Named parameters</em> at call </m> </td>
</tr>




<tr>
<td><pre>
fun mirror(v: Int) : Pair&ltInt,Int> {
	return Pair(v, -v)
}
val v = mirror(2)
<kc>------</kc>
println("${v.first}, ${v.second} ")  <kc>//2,-2</kc>

val(pos,neg) = mirror(3)
<kc>------</kc>
println( " pos=$pos neg=$neg " ) 	<kc>//pos=3 neg=-3</kc>  
</pre> </td>
<td><m><em>Multiple return values</em>. To extract the values into separate values, we can exploit
<bc>destructuring declarations</bc> (syntactic sugar)</m> 
<pre>
val(pos,neg) = mirror(3)
</pre>
</td>
</tr>



<td><pre>val sToNref = <k>::</k>sToN
println( sToNref )	
	<kc> //fun sToN(kotlin.String, kotlin.Int): kotlin.Int</kc> 
-------------------------
fun add( x:Int, y:Int ) : Int { return x+y }
println( exec23( <k>::</k>add ) )				<kc>//5</kc>

val x = <k>(::add)(5,6)</k>
println( x ) 		<kc>//11</kc>

</pre> 
<!--
<m>To obtain the output, include the dependency on:</m>
<pre>
<k>implementation</k> "org.jetbrains.kotlin:kotlin-reflect"
</pre>
-->
</td>
<td><em>Function reference</em>. <m>The</m> <bc>::</bc>  <m>operator creates a member reference or a (statically known) class reference.<br/>
The <em>reference</em> is a value of type <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-class/index.html" target="web">KClass</a>.<br/>
A Kotlin class reference is not the same as a Java class reference. To obtain a Java class reference, 
use the <bc>.java</bc> property on a <tt>KClass</tt> instance.</m>
 </td>
 
  
 <tr>
<td><pre>
var str = "Hello World"
str<k> .let</k> { println("$it!!") }	<kc>//Hello World!!</kc>

137<k> .let</k>  { println("$it!!") }	<kc>//137!!</kc>
 </pre> </td>
<td><m>
<h5>Standard library function <k>let</k></h5> 

<em>let</em>  takes the object it is invoked upon as the parameter and returns the result of the lambda expression.<br/>
It is a <bc>scoping function</bc>, wherein the variables declared inside the expression cannot be used outside.
<!-- https://www.journaldev.com/19467/kotlin-let-run-also-apply-with 
useful higher order functions implementing idiomatic patterns.
-->
</m>
 
</td>
</tr>

<!--
<tr>
<td><pre>
fun testRunFunction() {
    val logo = "Global-logo"
    val v1 = run{ 
        println("First start:$logo  ${curThread()}")
        Thread.sleep(200)
        val logo = "First-run"
        println("First ended : $logo")
        logo
    }
    val v2 = run {
        println("Second start:$logo ${curThread()}")
        Thread.sleep(300)
        val logo = "Second-run"
        println("Second ended: $logo ")
        logo
    }
    println("logo=$logo v1=$v1 v2=$v2" )
}

fun main(args: Array<String>) {
    println("BEGINS")
    testRunFunction()
    println("ENDS")
}
</pre> 
</td>
</tr>

 
<td><m>
<h5>Standard library function <k>run</k></h5> 

<em>run </em> calls the specified function block and returns its result.<br/>
    It is a combination of <bc>with()</bc> and <bc>let()</bc> library functions.<br/>
	Similar to the <tt>let</tt> function, the run function returns the last statement.<br/>
	Unlike <tt>let</tt>, the <tt>run</tt> function doesnâ€™t support the <bc>it</bc> keyword.
 https://www.journaldev.com/19467/kotlin-let-run-also-apply-with 
useful higher order functions implementing idiomatic patterns.

</m>
<pre>
<kc>//OUTPUT</kc>
BEGINS thread=main
Second start: Global-logo thread=main
First start : Global-logo thread=main
First ended : First-run
Second ended: Second-run 
logo=Global-logo v1=StandaloneCoroutine{.. v2=Second-run
ENDS thread=main
</pre>
</td>
</tr>
-->
</tbody>	
</table></center>
 

<h2><a id="clos"/>Closures and Callbacks</h2>
These examples are reported in  <a href="../src/kotlindemo/demoCps.kt" target="code">demoCps.kt</a>  (project <m><ks>it.unibo.kotlinIntro</ks></m>).
<br/><br/>

<center><table style="width:95%">
<tbody>	
<tr>
<td style="width:45%"><pre>
fun counterCreate()  : ( cmd : String ) -> Int {
    <ks>var localCounter = 0</ks>
    return { msg ->
        when (msg) {
            "inc" -> ++localCounter
            "dec" -> --localCounter
            "val" -> localCounter
             else -> throw Exception( "unknown" )
        }
    }
}

val c1 = <k>counterCreate()</k>
<kc>------</kc>
for( i in 1..3 ) <k>c1("inc")</k>
println("c1=${<k>c1("val")</k>}")	      <kc>//c1=3</kc>

val c2 = <k>counterCreate()</k>		<kc>//another instance</kc>
<kc>------</kc>
for( i in 1..3 ) <k>c2("dec")</k>
println("c2=${<k>c2("val")</k>}")	     <kc>//c2=-3</kc>
</pre> </td>
<td><h3>Lexical Closures</h3>
<m>The <em>closure</em> returned by <bc>counterCreate</bc> is "closed over" the variable <bc>localCounter</bc>.<br/>
We are reproducing oo programming style (<i>instance</i> and <i>state encapsulation</i>)</m> </td>
</tr>
<tr>
<td><pre>
fun doJobCps( n: Int  ){
    getInputCps( <kc>//lambda</kc>
        { input : String-> submitCps( n, input, {  
              msg ->  handle( msg )  
            } 
        )}<kc>//submitCps</kc>
     )<kc>//getInputCps</kc>	
}
fun getInputCps(<k>callback:( String )-> Unit</k>):Unit{
    println("Input  ... | ${curThread()}")
    callback( "myinputcps" )
}
fun submitCps(v:Int,msg:String,<k>callback:(String)->Unit</k>){
    println("Submit ... | ${curThread()}")
    callback( "$msg-$v" )
}
fun main() = runBlocking{
    println("BEGINS CPU=$cpus ${curThread()}")
    doJobCps( 10  )
    println("ENDS ${curThread()}")
}
</pre> </td>
<td><h3>Callbacks</h3>
<m><em>Callbacks</em> are quite common in <bc>event-loop</bc> architectures such as <b>JavaScript</b>.
The idea is to pass one function as a parameter to another function, and have this one invoked once the process has completed.
<br/>
In order to avoid the <bc>anti-pattern</bc> known as
 <a href="http://callbackhell.com/">callback hell</a>, people use other approaches such as <em>promises</em> or 
<em>Reactive Extensions</em> (<bc>Rx</bc>) (<tt>C#</tt>, <tt>.NET</tt>) .

 <br/><br/>
 The usage of callbacks leads to the
 <em>Continuation-passing style</em>  (see <a href="https://en.wikipedia.org/wiki/Continuation-passing_style" target="web">CPS</a>),
 quite diffused to handle 
 <a href="https://en.wikipedia.org/wiki/Asynchronous_I/O" target="web">Asynchronous I/O</a>
</m> 
<pre>
<kc>//OUPUT</kc>
BEGINS thread=main / nthreads=2
Input  ... | thread=main / nthreads=2
Submit ... | thread=main / nthreads=2
Handle myinputcps: 10 | thread=main / nthreads=2
ENDS thread=main / nthreads=2
</pre>
 
</td>
</tr>

<tr>
<td><pre>
fun showAction( msg: String ){
    println( msg )
}
fun readAction() : String{
    println("readaction  ... | ${curThread()}")
    return "myinput"
}
fun evalAction( v: Int, msg: String ) : String{
    println("evalaction ... | ${curThread()}")
    return "$msg:$v"
}

fun doJobNormal(n:Int){	<kc>//<k>print- eval-read</k> pattern</kc>
    val s = readAction()
    val v = evalAction( n, s )
    showAction( v )
}

-----------------------
   doJobNormal(10)		<kc>//output : myinput:100</kc>
}

</pre> </td>
<td><h3>Normal flow</h3>
 With reference to the set of functions on the left, let us execute a <em>Normal call sequence</em>:
The output is:</m>
<pre>
<kc>//OUPUT</kc>
readaction  ... | thread=main | nthreads=1
evalaction ...  | thread=main | nthreads=1
myinput:100
</pre>

 
</td>
</tr>

<tr>
<td><pre>
fun showAction( msg: String ){ println( msg ) }

fun readCps( <ks>callback</ks>:<k>( String )-> Unit</k> ) :Unit {
    println("readCps  ... | ${curThread()}")
    <ks>callback</ks>:( "myinputcps" )
}

---------------------
  readCps( { msg -> showAction(msg) }
</pre> </td>
<td><h3>Callbacks</h3>
<m><em>Callbacks</em> are quite common in <bc>event-loop</bc> architectures such as <b>JavaScript</b>.
The idea is to pass one function as a parameter to another function, and have this one invoked once the process has completed.
<br/>
</m> 
<pre>
<kc>//OUPUT</kc>
readCps  ... | thread=main | nthreads=1
myinputcps
</pre>
<m>  The usage of callbacks leads to the
 <em>Continuation-passing style</em>  (see <a href="https://en.wikipedia.org/wiki/Continuation-passing_style" target="web">CPS</a>),
 which is quite diffused to handle 
 <a href="https://en.wikipedia.org/wiki/Asynchronous_I/O" target="web">Asynchronous I/O</a>
</m>
</td>
</tr>

<tr>
<td><pre>
fun readCps( <ks>callback</ks>:<k>(String)-> Unit</k>  ):Unit{
    println("readCps  ... | ${curThread()}")
    <ks>callback</ks>( "myinputcps" )
}
fun evalCps(v:Int, msg:String, <ks>callback</ks>:<k>(String)-> Unit</k> ){
    println("evalCps ... | ${curThread()}")
    <ks>callback</ks>( "$msg: $v" )
}

fun <i>doJobCpsNoShortcut</i>( n: Int  ){
    readCps( <kc>//lambda</kc>
        { input : String-> evalCps( n, input, {  
              msg ->  showAction( msg )  
            } 
        )}<kc>//evalCps</kc>
     )<kc>//readCps</kc>	
}

fun <b>doJobCps</b>( n: Int  ){ <kc>//using lambda shortcut</kc>
	<k>readCps{evalCps( n, it) { showAction( it )}} </k> 
} 
---------------------
  doJobCps( 10 }
</pre> </td>
<td>
<h3>CPS  (Continuation Passing Style)</h3>
<m>The example on the left trasforms the normal <ks>print-eval-read pattern</ks> into a 
pattern <k>read-and-after-do</k>
</m>

<pre>
<kc>//OUPUT</kc>
readCps  ... | thread=main | nthreads=1
evalCps ... | thread=main | nthreads=1
myinputcps:10
</pre>
<m>
<h3>Callback hell</h3>
In order to avoid the <bc>anti-pattern</bc> known as
 <a href="http://callbackhell.com/">callback hell</a>, people use other approaches such as <em>promises</em> or 
<em>Reactive Extensions</em> (<bc>Rx</bc>) (<tt>C#</tt>, <tt>.NET</tt>) .
</m> 

</td>
</tr>



<tr>
<td><h3>Towards ASYNCHRONOUS PROGRAMMING</h3>
Let us suppose that the operation <bc>readCps</bc> takes a long time and that we do not want to block
the computation. </td>
<td>


As a solution modern langauages do introduce:

<ol>
<li>Threading</li>
<li>Callbacks</li>
<li>Futures, Promises et al.</li>
<li>Reactive Extensions</li>
<li>Coroutines</li>
</ol>

<m></m>
</td>
</tr>



<tr>
<td><pre>
fun readCpsAsynch( <ks>callback</ks>:<k>(String)-> Unit</k> ) : Unit{
  <k>kotlin.concurrent.thread(start = true)</k> {
	println("readCpsAsynch  ... | ${curThread()} ")
	<ks>Thread.sleep(3000)</ks>	<kc>//Long-term action</kc>
	println("readCpsAsynch received ")
	<ks>callback</ks>( "myinputasynchcps" )
  }
}

fun doJobAsynchCps( n: Int  ){
	readCpsAsynch{evalCps( n, it) { showAction( it )}} 
}

--------------------------
    doJobAsynchCps( 10  )
</pre> 
<m>
This example is reported in  <a href="../src/kotlindemo/demoCpsAsynch.kt" target="code">demoCpsAsynch.kt</a>  (project <ks>it.unibo.kotlinIntro</ks>).
</m>
</td>
<td><m>
<h3>ASYNCHRONOUS PROGRAMMING WITH CPS</h3>
As an example of <a href="https://en.wikipedia.org/wiki/Continuation-passing_style" target="web">CPS</a> in <em>Asynchronous programming</em>
(see <a href="https://en.wikipedia.org/wiki/Asynchrony_(computer_programming)" target="web">asynchronous</a> ),
let us simulate here the <tt>readCpsAsynch</tt> operation as an activity that runs in its own <bc>thread</bc>  and ends after <tt>1 sec</tt>.
<br/> 
Now, the <tt>main</tt> program ends immediately; the computation is executed in the thread activated for the input.
</m> 
<pre>
<kc>//OUPUT</kc>
BEGINS CPU=8 thread=main | nthreads=1
work done in time= 6
ENDS thread=main | nthreads=2
readCpsAsynch  ... | thread=Thread-0 | nthreads=1 
readCpsAsynch received 
evalCps ... | thread=Thread-0 | nthreads=2
myinputasynchcps:10
</pre>
<m> 
Note the <a href="https://kotlinlang.org/docs/reference/java-interop.html#sam-conversions" target="web">Single Abstract Method conversion</a> 
(<bc>SAM</bc>) in <tt>kotlin.concurrent.thread</tt>: when an object implements a <tt>SAM</tt> interface, we can pass a lambda instead.
</m> 

</td>
</tr>

</tbody>	
</table></center>

<h2><a id="coroutinesIntro"/>Introduction to coroutines</h2>

<ul>

 

<li>Essentially, a <em>Coroutine</em> is a light-weight thread that can be activated with a 
<em>Coroutine builder</em> into a <em>CoroutineScope</em>.
<br/><br/></li>


<li>
Coroutines can be executed concurrently using a multi-threaded dispatcher like the 
<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html"  target="web">Dispatchers.Default</a>.
It presents all the usual concurrency problems. 
See <a href="https://kotlinlang.org/docs/reference/coroutines/shared-mutable-state-and-concurrency.html" target="web">Kotlin Shared mutable state and concurrency</a>.
<br/><br/></li>

<li>By default, coroutines are run on a shared pool of threads. 
Threads still exist in a program based on coroutines, but one thread can run many coroutines, so there's no need for too many threads.
<br/><br/></li> 

<li>
Kotlin Coroutines enhance <em>asynchronous programming</em> by being lightweight and essentially faster than a thread as they are <em>stackless</em>. 
What this means from a multiprocessing perspective, is that Kotlin Coroutines don't map on the native CPU thread, 
hence there's no context-switching on the processor.
<br/><br/></li>

<li>The execution of a coroutine always happens inside a <em>Coroutine Context</em> that defines <b>how</b> the coroutine will be executed.
It includes a coroutine <em>Dispatcher</em>. 
A <em>Coroutine Context</em> can be composed  by several element types. <!-- to create <em>composed behaviors</em>. -->
<br/><br/></li>


<li>
Every coroutine has a context that is represented by an instance of 
<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/-coroutine-context/"  target="web">CoroutineContext</a> interface. 
A context is a set of elements and current coroutine context is available via <m><k>coroutineContext</k></m> property.<br/>
A <m><k>scope</k></m> is just a reference to a context.
<br/><br/></li>

<li>Coroutines are computations that can be <m><k>suspended</k></m> without blocking a thread.
They are based on the concept of <em>Continuation-passing style</em> (<m><k>CPS</k></m>) programming.
<br/><br/></li>

<li>Coroutines do not rely on features of the <tt>Operating System</tt> or the <tt>JVM</tt>. Instead, a <bc>Continuation</bc> is added to every suspending function as 
an additional parameter according to the <bc>CPS</bc> style. The compiler produces a <em>state machine</em> to handle suspension.
<br/><br/></li>


<li>
A coroutine itself is represented by a 
<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html" target="web">Job</a>. 
It is responsible for coroutine's lifecycle, cancellation, and parent-child relations. 
A current job can be retrieved from a current coroutine's context.
<br/><br/></li>

<m></m>
</ul>
<br/>


<h3>Examples</h3>
The examples hereunder are reported in  <a href="../src/kotlindemo/demoCoroutinesIntro.kt" target="code">demoCoroutinesIntro.kt</a>  
(project <m><ks>it.unibo.kotlinIntro</ks></m>).
The main program now waits for a command from the user to select the demo to run:
<hr/>
<pre>
fun readInt() : Int { print(">"); return readLine()!!.toInt() }

fun doDemo( input : Int ){
	println("BEGINS CPU=$cpus ${curThread()}")
	when( input ){<m>
		1 ->  demoTodo =  { runBlockThread() }
		2 ->  demoTodo =  { GlobalScope.launch{ runBlockThread() } }
		3 ->  demoTodo =  { scopeDemo()								}
 		4 ->  demoTodo =  { scopeAsyncDemo()             	        }
		...
		else ->  { println("command unknown") }  //Note the block     </m>		
	} 			
	println( "work done in time= ${measureTimeMillis(  demoTodo )}"  )
	println("ENDS ${curThread()}")	
}

fun main() {
		var input =  readInt()
		while( input != 0 ){
			doDemo( input )
			demoTodo = 	{ println("nothing to do") }    
			input    =  readInt()
		}
  	    println( "BYE") 
}
</pre>
<hr/>

<center><table style="width:95%">
<tbody>	

<tr>
<td>
<h3>Conventional (Java) code</h3>
<pre>
fun runBlockThread(){	    
 <k>run {</k> <kc>//Calls a function block; returns its result</kc>
    println("thread sleeps ... : ${curThread()}")
    Thread.sleep(1500) 
    println("thread ends: ${curThread()}")
 <k>}</k>
}
------------------
runBlockThread()
</pre> </td>
<td><m>The current Thread (<tt>main</tt>) waits for <tt>1500</tt> msecs.<br></m>
<pre>
<kc>//OUTPUT</kc>
BEGINS CPU=4 thread=main | nthreads=1
thread sleeps ... : thread=main | nthreads=1
thread ends : thread=main | nthreads=1
work done in time= 1501
ENDS thread=main | nthreads=1
</pre>
</td>
</tr>



<tr>
<td>
 <h3>GlobalScope</h3> 
<m><ks>GlobalScope.launch</ks>  is used to launch <tt>top-level coroutines</tt>, which operate on the whole application lifetime. 
</m>
<pre>
<k>GlobalScope.launch{</k> runBlockThread() <k>}</k>
</pre> </td>
<td><m>
The <tt>runBlockThread</tt> is now called in the default Thread devoted to Coroutine execution. 
</m>
<pre>
<kc>//OUTPUT</kc>
BEGINS CPU=4 thread=main | nthreads=1
work done in time= 96
ENDS thread=main | nthreads=3
<ks>></ks>thread sleeps ... : thread=<k>DefaultDispatcher-worker-2</k> | nthreads=4
thread ends : thread=<k> DefaultDispatcher-worker-2</k>  | nthreads=4
</pre>
<m>
Note that the 'program' ends immediately. <br/>
The output after <ks>></ks> appears since our main waits for input. </m> 
</m>
</td>
</tr>


<tr>
<td>
<m>
The example above  shows that the coroutine works with reference to the <bc>Dispather.Deafault</bc>. <br/>
A <em>Dispatcher</em> determines the thread in which a coroutine will be executed. It can be provided by the<tt> Coroutine Scope</tt>
or specified using a builder.

</td>
<td>
<h3>On Dispatchers</h3> 
<m>
A dispatcher can be provided in two ways:

<ul>
<li>By the <bc>coroutine scope</bc>.
See  also <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html" target="web"> 
Coroutine Scope</a> <br/><br/></li>
<li><bc>Explicitly</bc>: the coroutine builder receives a coroutine context as a first parameter.
See  <a href="#Dispatchers">Dispatchers</a> later on.</li>
</ul>
</m>
</td>
</tr>

<tr>
<td>
 <h3>CoroutineScope</h3> 
  <m><ks>CoroutineScope.</ks>  defines a scope for new coroutines. 
  Every coroutine builder is an extension on CoroutineScope and inherits its <tt>coroutineContext</tt> to automatically propagate both context elements and cancellation.
 </m>  
<pre>
fun scopeDemo (){
	val scope = CoroutineScope( Dispatchers.Default )
	println( <ks>scope.coroutineContext</ks> )
	<k>scope.launch</k>{ runBlockThread() } 	
}
</pre> </td>
<td><m>
The <tt>runBlockThread</tt> is now called in a new Coroutine scope. 
</m>
<pre>
<kc>//OUTPUT</kc>
BEGINS CPU=4 thread=main | nthreads=5
<ks>[JobImpl{Active}@606d8acf, DefaultDispatcher]</ks>
work done in time= 2
ENDS thread=main | nthreads=5
thread sleeps ... : thread=DefaultDispatcher-worker-2 | nthreads=4
>thread ends : thread=DefaultDispatcher-worker-2 | nthreads=4
</pre>
<m>
</m>
</td>
</tr>

<tr>
<td>
<pre>
val n=10000	<m><kc>//number of Thread or Coroutines to launch</kc></m>
val k=1000	<m><kc>//times an action is repeated by each Thread or Coroutine</kc></m>


fun <ks>manyThreads()</ks>{
	var counter=0
 	var iter = 0;
	val time = measureTimeMillis{
	  val jobs = List(n){
		Thread(){
			run(){
				iter++	 
				//println("thread $iter starts ")
				repeat( k ){ counter++}
 			}
		}			
		}
		jobs.forEach{ it.start() }
		jobs.forEach{ it.join()  }
 	}
	println("manyThreads time= $time counter=$counter")
}
</pre> </td>
<td>
 <h3>Many Threads</h3> 

<m>The function  <ks>manyThreads</ks> activates <tt>n=10000</tt> threads; each thread increments a global counter
<tt>k=1000 times</tt>.</m>
<pre>
<kc>//OUTPUT</kc>
BEGINS CPU=4 thread=main | nthreads=1
manyThreads time= 1893 counter=<k>9989342</k>
work done in time= <k>1897</k>
ENDS thread=main | nthreads=1
</pre>
<m>Question: why the final value of the counter is not <tt>n*k = 10000000</tt>?.
</m>
</td>
</tr>


<tr>
<td>

<pre>
fun <ks>manyCoroutines()</ks>{
	var counter=0
    val time = measureTimeMillis {
	  val jobs = List(n) {
		  <k>CoroutineScope( Dispatchers.Default ).launch</k> {
			repeat(k) { counter++ }
	  }
	}
	CoroutineScope( Dispatchers.Default ).launch {
		jobs.forEach { <k>it.join()</k> } <m><kc>//wait for termination of all coroutines</kc></m>
	}
	}
	println("manyCoroutines time= $time counter=$counter")
}
</pre> </td>
<td>
 <h3>Many Coroutines</h3> 

<m>The function  <ks>manyCoroutines</ks> activates <tt>n=10000</tt> coroutines; each coroutine increments a global counter
<tt>k=1000 times</tt>.</m>
<pre>
<kc>//OUTPUT</kc>
BEGINS CPU=4 thread=main | nthreads=1
manyCoroutines time= 151 counter=<k>9875922</k>
work done in time= <k>152</k>  <kc>//!!!!!!!!!!!!!</kc>
ENDS thread=main | nthreads=5
</pre>
<m>The execution time is now much less than the case of using threads.<br/>
Question: why the final value of the counter is not <tt>n*k = 10000000</tt>?.
</m>
</td>
</tr>

</tbody>	
</table></center>

<h3>A closer look to coroutines</h3>
From  <a href="https://medium.com/@elizarov/coroutine-context-and-scope-c8b255d59055"  target="web">Elizarov</a> we know that:
<ul>
 

<li>
A coroutine is typically launched using <m><k>launch coroutine builder</k></m>:
<pre>
fun <k>CoroutineScope.launch</k>(		//<kc>extension function on CoroutineScope</kc>
    <ks>context</ks>: CoroutineContext = EmptyCoroutineContext,		//<kc>parameter</kc>
    // ...	
): <k>Job</k>
</pre>
<m><k>launch</k></m> is defined as an extension function of the
<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/-coroutine-context/"  target="web">CoroutineScope</a> interface
that consists of a sole property (<m><kc>val  coroutineContext: CoroutineContext</kc></m>).
<br/>
 CoroutineScope  merges (using the <m><k>plus</k></m> operator of the context) the scope context with the <m><ks>context</ks></m> parameter, 
whose elements are taking precedence over the elements from the scope context. <br/>
The resulting context is 
the parent context of the new coroutine. The new coroutine creates its own child <m><k>Job</k></m> instance (using a job from this context as its parent) 
and defines its child context as a parent context plus its job.<br/>

<center><img src="./img/coroutinesScopes.png" alt="coroutinesScopes.png" width="70%"/></center>
<br/><br/></li>

<li>
By convention, a context in <m><kc>CoroutineScope</kc></m> contains a <m><k>Job</k></m> that is going to become a parent of new coroutine 
(with the exception of <m><k>GlobalScope</k></m> that you should avoid anyway - see: 
<a href="https://medium.com/@elizarov/the-reason-to-avoid-globalscope-835337445abc" target="web">The reason to avoid GlobalScope</a>).
<br/><br/></li>

 
<li>
The difference between a context and a scope is in their intended purpose:
	<ul>
	<li>
	The intended purpose of <m><kc>CoroutineScope</kc></m> receiver in launch and in all the other coroutine builders is to reference 
	a scope in which new coroutine is launched.
	</li>

	<li>
	The intended purpose of <m><kc>context: CoroutineContext</kc></m> parameter in launch is to provide additional context elements to override elements 
	that would be otherwise inherited from a parent scope.
	</li>
	</ul>
<br/></li> 
<li>Every coroutine builder function (like <tt>launch</tt>, <tt>async</tt>, <tt>runBlocking</tt>, etc.) :
	
	<ul>
	<li>is an extension on <em>CoroutineScope</em> interface
	and inherits its abstract read-only property <tt>coroutineContext: CoroutineContext</tt> to  automatically propagate both context elements and cancellation.
	<ul>
		<li><bc>GlobalScope</bc>: the coroutine affects the whole Application</li>
		<li><bc>CoroutineScope</bc>: defines a scope for new coroutines</li>
	</ul>
	 </li>

	<li>
	accepts as parameter one of the main <em>Dispatcher</em> (<tt>Default, IO, newSingleThreadContext , Unconfined, Main</tt>)
	 </li>

	<li>	
	  like every scoping function (<tt>coroutineScope, withContext</tt>, etc) 
	  provides its own scope with its own <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html" target="web">Job</a>
	  instance into the inner block of code it runs. <br/>
	  By convention, they all wait for all the coroutines inside their block to complete before completing themselves, 
	  thus enforcing the discipline of <m><k>structured concurrency</k></m>.
	</li>
	</ul>


 	</ul>



<h2><a id="suspend"/>Suspending functions</h2>
The examples hereunder are reported in  <a href="../src/kotlindemo/demoSuspended.kt" target="code">demoSuspended.kt</a>  (project <m><ks>it.unibo.kotlinIntro</ks></m>).
<br/><br/>
<!--
The main program now waits for a command from the user to select the demo to run:
<hr/>
<pre>
</pre>
<hr/>
-->
<center><table style="width:95%">
<tbody>	
<tr>
<td>
<h3>launch & runBlocking</h3> 
<m><bc>runBlocking</bc> is a  <tt>Coroutine Builder</tt> wrapper that runs new coroutine and blocks current thread interruptibly until its completion. 
<br/>
Using <bc>launch</bc>, the coroutine is launched in the
scope of the outer coroutine (that of <bc>runBlocking</bc> in this case). 
</m>
<pre>
fun main() = <k>runBlocking</k> { 
	println("BEGINS CPU=$cpus ${curThread()}")
	<k>launch{</k>  runBlockThread()  <k>}</k>	
	println("ENDS ${curThread()}")	
}
</pre> </td>
<td><m>
No <tt>Thread.sleep</tt> tis required now.  <br/>
</m>

<pre>
<kc>//OUTPUT</kc>
BEGINS CPU=4 thread=main | nthreads=1
ENDS thread=main | nthreads=1
thread sleeps ... : thread=main | nthreads=1
thread ends : thread=main | nthreads=1
</pre>
<m>
Since we use <bc>launch</bc> instead of <bc>GlobalScope.launch</bc>, then the coroutine is launched in the
scope of the outer <bc>runBlocking</bc> coroutine.<br/>
This is an example of  <em>structured concurrency</em>: coroutines confined to different scopes 
are more maintainable and manageable.

<!-- <bc>runBlocking</bc>  is designed to bridge regular blocking code to libraries written in suspending style, 
to be used in main functions and in tests. -->
</m>
</td>
</tr>


<tr>
<td>
<h3>Launch and join</h3> 
<m>Coroutines started by  <bc>launch</bc> return a  <k>Job</k> immediately,  which we can use to <tt>cancel</tt> 
the computation or <em>await</em> its completion with <bc>join</bc>.</m> 
<pre>
fun main() =  <k>runBlocking</k> {  
	println("BEGINS CPU=$cpus ${curThread()}")
	<k>val job</k> =  <k>launch</k>{ runBlockThread()  }
	<k>job.join()</k>
 	println("ENDS ${curThread()}")
}
</pre> 
</td>
<td><m>
<br/>
</m>

<pre>
<kc>//OUTPUT</kc>
BEGINS CPU=4 thread=main | nthreads=1
thread sleeps ... : thread=main | nthreads=1
thread ends : thread=main | nthreads=1
ENDS thread=main | nthreads=1
</pre>
<m>
We can remove the explicit <bc>join</bc>, since <tt>runBlocking</tt> won't complete before all of its 
child coroutines finish.
</m>
</td>
</tr>



<tr>
<td>
<h3>delay</h3> 
<m><bc>delay</bc> is a special <i>suspending function</i> that does not block a thread, but suspends the work.
<hr/>
A function that can <bc>suspend</bc> its work cannot be called from a normal function,
but only from <k>another suspend</k> function or from a <em>Coroutine</em>.
<hr/>
</m> 
<pre>
<k>suspend</k> fun ioBoundFun(){
	val <ks>timeElapsed</ks> = <ks>measureTimeMillis</ks> {
		println("IO operation | STARTS in ${curThread()}")
		<k>delay</k>(1000)
	}
	println("IO operation | Done, TIME=<ks>$timeElapsed</ks>")
}

fun main() =  <k>runBlocking</k> {  
	println("BEGINS CPU=$cpus ${curThread()}")
	<ks>ioBoundFun()</ks>
	println("BYE")
	println("ENDS ${curThread()}")
}
</pre> </td>
<td>
<pre>
<kc>//OUTPUT</kc>
BEGINS CPU=4 thread=main | nthreads=1
IO operation | STARTS in thread=main | nthreads=1
IO operation | Done, TIME=1021
ENDS thread=main | nthreads=1
</pre>
<m>If we execute:</m>
<pre>
fun main() =  <k>runBlocking</k> {  
	<k>launch</k>{ <ks>ioBoundFun()</ks> }
	println("BYE")
}
</pre>
<m>the output is:</m>
<br/>
<pre>
<kc>//OUTPUT</kc>
BEGINS CPU=4 thread=main | nthreads=1
ENDS thread=main | nthreads=1
IO operation | STARTS in thread=main | nthreads=1
IO operation | Done, TIME=1006
</pre>

</td>
</tr>
 

 <tr>
<td>
<h3>Coroutine builder async </h3>
<m>The <bc>async</bc> builder creates new coroutine and returns a <em>promise</em> (also known as <tt>future</tt>), 
(of type <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/" target="web">Deferred</a>
in Kotlin): it promises to compute a value which we can wait for or  request at any time.
</m>
<pre>
suspend fun activate(){	
    val job1 = <k>CoroutineScope( Dispatchers.Default ).async</k> {
        ioBoundFun()
    }
    val job2 = <k>CoroutineScope( Dispatchers.Default ).async</k>{
        ioBoundFun()
    }
    if(! job1.isCompleted || ! job2.isCompleted) 
		println("Waiting for completion")
    val end1 = <k>job1.await()</k>	<m><kc>//only from a coroutine or another suspend</kc></m> 	 
    val end2 = <k>job2.await()</k>
    println("All jobs done; end1=$end1 end2=$end2")
}

fun main() = <k>runBlocking</k>{
	println("BEGINS CPU=$cpus ${curThread()}")
	activate()
	println("ENDS ${curThread()}")
}
</pre> </td>
<td><m>
<br/><br/>
 The method <bc>await</bc> on the promise allows us to get the value.


</m> 
<pre>
<kc>//OUPUT</kc>
BEGINS CPU=4 thread=main | nthreads=1
Waiting for completion
IO operation | STARTS in thread=DefaultDispatcher-worker-2 | nthreads=5
IO operation | STARTS in thread=DefaultDispatcher-worker-1 | nthreads=5
IO operation | Done, TIME=1011
IO operation | Done, TIME=1011
All jobs done; end1=kotlin.Unit end2=kotlin.Unit
ENDS thread=main | nthreads=6
</pre>
</td>
</tr>

</tbody>	
</table></center>


 
<h2><a id="channels"/>Channels</h2>
Channels provide a way to transfer a <tt>streams of values</tt>. <br/>
<bc>send</bc> and <bc> receive</bc>  are
<em>suspending functions</em> used for providing and consuming objects from the channel, implemented with a <tt>FIFO</tt>
strategy.
<br/><br/>
<m>The sender is suspended when the channel is full
and resumes as soon as the receiver consumes the data. This concept is often referred to as <k>Backpressure</k> and helps to
prevent a channel from being flooded with more elements than the receivers can actually process.</m>
<br/><br/>
Kotlin defines several types of channels:
<br/>

<em>Unbuffered Channels</em>:
<ul>
 <li><bc>RendezvousChannel</bc> (the buffer has capacity <tt>0</tt> and the sender suspends until the element is consumed)</li>
</ul>

<em>Buffered Channels</em>:
<ul>
<li><bc>LinkedListChannel</bc></li>
<li><bc>ArrayChannel</bc></li>
<li><bc>ConflatedChannel</bc> (the buffer has capacity <tt>1</tt> and the sender overrides an element not cosumed)</li>
</ul>
<hr/>
The examples hereunder are reported in  <a href="../src/kotlindemo/demoChannels.kt" target="code">demoChannels.kt</a>  (project <m><ks>it.unibo.kotlinIntro</ks></m>).
<br/><br/>
 
<center><table style="width:95%">
<tbody>	
<tr>
<td style="width:45%"><pre>
<k>suspend</k> fun channelTest(scope : CoroutineScope){
val n = 5
val <ks>channel</ks> = <k>Channel&ltInt>(2)</k>

     val sender = scope.launch {
         repeat( n ) {
             <ks>channel</ks><k>.send( <ks>it</ks> )</k>
             println("SENDER | sent $it in ${curThread()}")
         }
     }
     
	 <ks>delay(500)</ks> <kc>//The receiver starts after a while ...</kc>
     
	 val receiver = scope.launch {
         for( i in 1..n ) {
             val v = <ks>channel</ks><k>.receive()</k>
             println("RECEIVER | receives $v in ${curThread()}")
         }
     }
}
 
fun main() = runBlocking{
	println("BEGINS CPU=$cpus ${curThread()}")
	<ks>channelTest()</ks>
	println("ENDS ${curThread()}")
}
 </pre> </td>
<td><m>
The example shows the usage of an <bc>ArrayChannel</bc> of capacity <tt>2</tt>. 
</m>

<pre>
<kc>//OUTPUT</kc>
BEGINS CPU=4 thread=main | nthreads=4
SENDER | sent 0 in thread=main | nthreads=4
SENDER | sent 1 in thread=main | nthreads=4
ENDS thread=main | nthreads=4
RECEIVER | receives 0 in thread=main | nthreads=4
RECEIVER | receives 1 in thread=main | nthreads=4
RECEIVER | receives 2 in thread=main | nthreads=4
SENDER | sent 2 in thread=main | nthreads=4
SENDER | sent 3 in thread=main | nthreads=4
SENDER | sent 4 in thread=main | nthreads=4
RECEIVER | receives 3 in thread=main | nthreads=4
RECEIVER | receives 4 in thread=main | nthreads=4
</pre>


</td>
</tr>

</tbody>	
</table></center>

<div class="remark">
Motto: Do not communicate by sharing memory; instead, share memory by communicating.
</div>

 
 


<h2><a id="kotlinprodcons"/>Producers-consumers in Kotlin</h2>

<ul>
<li>The pattern where a coroutine is  producing a sequence of elements is quite common. 
This is a part of <em>producer-consumer pattern</em> that is often found in concurrent code. 
You could abstract such a producer into a function that takes <bc>channel</bc> as its parameter, 
but this goes contrary to common sense that results must be returned from functions.
<br/><br/>
</li>
<li>There is a convenient coroutine builder named 
<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/produce.html"  target="web"><bc>produce</bc></a>
 that makes it easy to do it right on producer side, 
and an extension function <bc>consumeEach</bc>, that replaces a for loop on the consumer side.
<br/><br/>
</li>
<li>The coroutine builder 
<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/produce.html"  target="web"><bc>produce</bc></a> 
is associated with the channel that it sends elements to (a 
<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/"  target="web"><bc>ReceiveChannel</bc> </a>
interface) requires a specific <tt>CoroutineContext</tt> (as with <bc>launch</bc> or <bc>async</bc>) and works as follows:
<ul>
<li>suspends after a value is produced and  resumes when a new value is requested (similar to suspending sequences and iterators)</li>
 
<li>the body of the suspending lambda that is passed can suspend at any point</li>
<li>a value from a producer can only be received in a suspending computation </li>
<li>the channel has no buffer by default is closed when the coroutine completes</li>
</ul>
</li>
 
</ul>
<m></m>
 
<center><table style="width:98%">
<tbody>	

<tr>
<td style="width:45%">
<h3 id="produce">Coroutine builder <bc>produce</bc> </h3>
<pre>
 
val <ks>simpleProducer : ReceiveChannel&lt;Int>?</ks> = null
fun startProducer(scope : CoroutineScope ){
	simpleProducer =
	scope.produce {
		for( i in 1..3 ){
			println( "producer produces $i in  ${curThread()}")
			<k>send( i )</k>
		}
  }

<k>suspend</k> fun consume(){
    val v = <ks>simpleProducer!!</ks>.<k>receive()</k>
    println( "consume receives ${v} in ${curThread()}" )
    <ks>simpleProducer!!</ks>.<k>consumeEach</k> {
      println( "consume receives $it in ${curThread()}" )
    }
}

fun main() = runBlocking{
    println("BEGINS CPU=$cpus ${curThread()}")
    <ks>startProducer(this); 
	consume()</ks>
    println("ENDS ${curThread()}")
}
</pre>
</td>
<td>
This example is reported in <a href="../src/prodCons/simpleProducerKotlin.kt" target="code">simpleProducerKotlin.kt</a>
<br/><br/>
<m>  
The coroutine builder <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/produce.html" target="web"><bc>produce</bc></a> 
takes a suspending lambda as a parameter; only the code within this lambda can send items to the channel.
The channel has <em>no buffer by default</em>; it is closed when the coroutine completes
</m>
<br/> 
<pre>
<kc>//OUTPUT</kc>
BEGINS CPU=4 thread=main | nthreads=1
producer produces 1 in  thread=main | nthreads=1
producer produces 2 in  thread=main | nthreads=1
consume receives 1 in thread=main | nthreads=1
consume receives 2 in thread=main | nthreads=1
producer produces 3 in  thread=main | nthreads=1
consume receives 3 in thread=main | nthreads=1
ENDS thread=main | nthreads=1
</pre>
<m> </m>
 
</td>
</tr>

<tr>
<td>
<h3>Many-type producer</h3>

<pre>
val context = newSingleThreadContext("myThread")
var producer : <k>ReceiveChannel<Any>?</k> <ks>= null</ks>

fun createProducer(scope : CoroutineScope ){
    producer =
    <k>scope.produce(context, 0)</k>{
        println( "producer sends 5.2   in ${curThread()}")
        <k>send(5.2)</k>
        println( "producer sends a   in ${curThread()}")
        <k>send("a")</k>
        println( "producer sends 100 in ${curThread()}")
        <k>send(100)</k>
    }
}

val <ks>producer</ks>: <k>ReceiveChannel&lt;Any></k> =
    GlobalScope.produce(context, 1){
        println( "producer sends 5   in ${curThread()}")
        <k>send(5.2)</k>
        println( "producer sends a   in ${curThread()}")
        <k>send("a")</k>
        println( "producer sends 100 in ${curThread()}")
        <k>send(100)</k>
    }

suspend fun doconsume(){
    val v = <k>producer!!.receive()</k>		<kc>//the first item</kc>
    println( "doconsume receives1 $v in ${curThread()}")
    <k>producer!!.consumeEach</k> { 
	  println( "doconsume receives2 $it in ${curThread()}") }
}

</pre>
</td>
<td>
This example is reported in <a href="../src/prodCons/prodConsKotlin.kt" target="code">prodConsKotlin.kt</a>
<br/><br/>

<m>When channel <bc>capacity = 0</bc> (default), the output is:</m> 
<pre>
<kc>//OUTPUT</kc>
BEGINS CPU=4 thread=main | nthreads=1
producer sends 5.2   in thread=myThread / nthreads=2
producer sends a   in thread=myThread / nthreads=2
doconsume receives1 5.2 in thread=main / nthreads=2
doconsume receives2 a in thread=main / nthreads=2
producer sends 100 in thread=myThread / nthreads=2
doconsume receives2 100 in thread=main / nthreads=2
ENDS thread=main | nthreads=2
</pre>
<m>When channel <bc>capacity = 3</bc>, the output is:</m>
<pre>
<kc>//OUTPUT</kc>
BEGINS CPU=4 thread=main | nthreads=1
producer sends 5.2   in thread=myThread / nthreads=2
producer sends a   in thread=myThread / nthreads=2
producer sends 100 in thread=myThread / nthreads=2
doconsume receives1 5.2 in thread=main / nthreads=2
doconsume receives2 a in thread=main / nthreads=2
doconsume receives2 100 in thread=main / nthreads=2
ENDS thread=main | nthreads=2
</pre>
 
 
 
</td>
</tr>

<tr>
<td style="width:45%">
<h3>Many consumers</h3>
<pre>
val <ks>aProducer</ks>:<k>ReceiveChannel&lt;Int>=GlobalScope.produce</k>{
    for( i in 1..3 ){
        println( "aProducer produces $i in ${curThread()}")
        <k>send( i )</k>
    }
}

fun consumer1(scope: CoroutineScope){
 <k>scope.launch</k>{
	delay(100)
	val v = <ks>aProducer</ks>.<k>receive()</k>
	println( "consumer1 receives ${v} in ${curThread()}" )
 }
}
fun consumer2(scope: CoroutineScope){
 <k>scope.launch</k>{
	for( i in 1..2 ) {
	  val v = <ks>aProducer</ks>.<k>receive()</k>
	  println("consumer2 receives ${v} in ${curThread()}")
	  delay(100)
	}
 }
}

fun main() = runBlocking{
  println( "BEGIN")
  consumer1(this )
  consumer2(this)
  println( "END")
}
</pre>
</td>
<td>
This example is reported in <a href="../src/prodCons/prodManyConsKotlin.kt" target="code">prodManyConsKotlin.kt</a>
<br/><br/>

<br/>The output is:</m>
<pre>
<kc>//OUTPUT</kc>
aProducer produces 1 in thread=DefaultDispatcher-worker-1 / nthreads=4
BEGINS CPU=4 thread=main | nthreads=4
ENDS thread=main | nthreads=4
consumer2 receives 1 in thread=main / nthreads=4
aProducer produces 2 in thread=DefaultDispatcher-worker-1 / nthreads=4
aProducer produces 3 in thread=DefaultDispatcher-worker-1 / nthreads=4
consumer1 receives 2 in thread=main / nthreads=4
consumer2 receives 3 in thread=main / nthreads=5
</pre>
 
 
</td>
</tr>

</tbody>	
</table></center>
 
 
<h2><a id="actors"/><a href="https://kotlinlang.org/docs/reference/coroutines/shared-mutable-state-and-concurrency.html#actors" target="web">Kotlin Actors</a></h2>
<ul>
<li>An actor is an entity made up of a combination of a <em>coroutine</em>, the state that is confined and encapsulated into this coroutine, 
and a <em>channel</em> to communicate with other coroutines. 
<br/> <br/> </li>
<li>The coroutine builder named  <k>actor</k> conveniently combines actorâ€™s mailbox channel into its scope to receive messages from 
and combines the send channel into the resulting job object, so that a single reference to the actor can be carried around as its handle.
<br/><br/>  
</li>
<li>The <bc>actor</bc> <i>coroutine builder</i> <em>is a dual of</em> <bc>produce</bc> <i>coroutine builder</i>, 
since a producer is associated with the channel that it <i>sends</i> elements to.
<br/><br/>
</li>
<li>This combination of actor-related mechanisms opens the way to the concept of <em>state share by communication</em>.
</li>
</ul>
<m>
</m>

<h3>An example</h3>
<br/>
<center><table style="width:95%">
<tbody>	

<tr>
<td style="width:50%"><pre>
var senderActor   : SendChannel<String>?  = null
var receiverActor : SendChannel<String>?  = null

fun startReceiver( scope : CoroutineScope){
	receiverActor = <k>scope.actor<String></k> {  
		<kc>//actor is a coroutine builder (dual of produce)</kc>
		println("receiverActor STARTS")
		var msg = <k>channel.receive()</k>
		while( msg != "end"){
			println("receiverActor receives $msg")
			msg = <k>channel.receive()</k>
		}
		println("receiverActor ENDS")
	}
}

fun startSender( scope : CoroutineScope){
	senderActor = <k>scope.actor<String></k> {  
		<kc>//actor is a coroutine builder (dual of produce)</kc>
		println("senderActor STARTS")
 		<k>receiverActor!!.send("Hello1")</k>
		delay(500)
 		<k>receiverActor!!.send("Hello2")</k>
		delay(500)
		<k>receiverActor!!.send("end")</k>
		println("senderActor ENDS")
 	}
}

fun main() = runBlocking{
    println("BEGINS CPU=$cpus ${curThread()}")
 	startReceiver( this )
	startSender( this )
    println("ENDS ${curThread()}")
}
</pre>
</td>
<td>
This example is reported in  <a href="../src/kotlindemo/demoActors.kt" target="code">demoActors.kt</a>  (project <m><ks>it.unibo.kotlinIntro</ks></m>).
<br/><br/><br/>
<center><img src="./img/demoActor0.png" alt="demoActor0.png" width="70%"/></center>

<m>A Kotlin (experimental) 
<a href="https://kotlinlang.org/docs/reference/coroutines/shared-mutable-state-and-concurrency.html#actors" target="web">actor</a>:
<ul>
<li>has type (interface) <bc>SendChannel&ltT></bc>, where <bc>T</bc> is the type of message it can handle<br/></br></li>
<li>confines the access of its state to a single <bc>Coroutine</bc><br/></br></li>
<li>is associated with the 
<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-channel/" target="web"><bc>channel</bc></a>
(<tt>unbuffered</tt> by default ) that it receives messages from<br/></br></li>
<li>modifies the state by handling the messages received on its 
<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-channel/" target="web"><bc>channel</bc></a><br/></br></li>
<li>works in a message-driven way</li>
</ul>
</m>
</td>
</tr>

 
</tbody>	
</table></center>



<h3>An actor working as a counter</h3>
 
<ul>

<li>The first step of using an actor usually consists in defining a class of messages that an actor is going to process.
Kotlin's <a href="https://kotlinlang.org/docs/reference/sealed-classes.html"  target="web"><m><k>sealed classes</k></m></a> are well suited for that purpose. However,
In the next example, we will use a conventional class (<m><ks>CounterMsg</ks></m>).<br/><br/>
</li>
<li>The class <m><ks>CounterMsg</ks></m> defines a field of interface 
<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-completable-deferred/" target="web"><m><k>CompletableDeferred</k></m></a>.
It is a 
<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/" target="web"><m><k>Kotlin Deferred</k></m></a> 
that can be completed via public functions <bc>complete</bc> or <bc>cancel</bc>.
All functions on this interface and on all interfaces derived from it, are <bc>thread-safe</bc> and can be safely invoked 
from concurrent coroutines without external synchronization.<br/><br/>
</li>


<li>We will use also an Extension function on <tt>CoroutineScope</tt> that 
launches <tt>n</tt> coroutines all doing the same action <tt>k</tt> times and measures the completion time:
<pre>
suspend fun <k>CoroutineScope.manyRun</k>( action: <k>suspend () -> Unit</k> ) {
    val n=100		<kc>//number of coroutines to launch</kc>
    val k=1000		<kc>//times an action is repeated by each coroutine</kc>
    val time = measureTimeMillis {
        val jobs = List(n) {
            <k>launch</k> { repeat(k) { action() }  }
        }
        jobs.forEach { it.join() } <kc>//wait for termination of all coroutines</kc>
    }
    println("Completed ${n * k} actions in $time ms")
}

</pre>
</li>
</ul>
 


<m></m>
<br/>
<center><table style="width:95%">
<tbody>	

<tr>
<td>
<pre>
class <ks>CounterMsg</ks>(
	val cmd:String,
	val response: <k>CompletableDeferred<Int></k>?<ks>=null</ks>){
}

fun <ks>createCounter</ks>( scope : CoroutineScope ) : SendChannel<CounterMsg>  {
 val counterActor = <k>scope.actor<CounterMsg></k> {
	var k = 0 	<kc>//actor state</kc>
	for (<k>msg in channel</k>) { <kc>// iterate over incoming messages</kc>
	   <m>if( k>0 && k % 10000 == 0  && msg.cmd != "GET" )
		println("${msg.cmd} | $k in ${curThread()} full=${channel.isFull}")</m>
		when ( msg.cmd ) {
			<ks>"INC"</ks> -> k++
			<ks>"DEC"</ks> -> k--
			<ks>"GET"</ks> -> <k>msg.response?.complete</k>(k)
			else -> throw Exception( "unknown" )
		}
	  }
	}
 return counterActor
}

<k>suspend</k> fun <ks>getIntialValue</ks>(counterActor: SendChannel<CounterMsg>){
    val initVal = CompletableDeferred<Int>()
    <k>counterActor.send(CounterMsg("GET", initVal))</k>
    println("Counter INITIAL VALUE=${<k>initVal.await()</k>}")	
}

<k>suspend</k> fun <ks>sendManyMessages</ks>( 
			scope : CoroutineScope, counterActor: SendChannel<CounterMsg>){
	<ks>scope.manyRun</ks> {
        <k>counterActor.send</k>( <ks>CounterMsg("INC")</ks> )
    }
    val finalVal = CompletableDeferred<Int>()
    <k>counterActor.send</k>( )<ks>CounterMsg("GET", finalVal))</ks>)
    println("Counter FINAL VALUE= = ${<ks>finalVal</ks>.<k>await()</k>}")	
}

fun main() = <k>runBlocking</k>{
    println("BEGINS CPU=$cpus ${curThread()}")
	
	val counterActor = createCounter( this )	
	getIntialValue( counterActor )
	
	sendManyMessages(this, counterActor)
	
	counterActor.close() <kc>//shutdown the actor</kc>

    println("ENDS ${curThread()}")
}
</pre>
<m></m> 
</td>
<td>
This example is reported in  <a href="../src/kotlindemo/demoActorCounter.kt" target="code">demoActorCounter.kt</a>  (project <m><ks>it.unibo.kotlinIntro</ks></m>).
<br/><br/> 
<center><img src="./img/demoActorCounter.png" alt="demoActorCounter.png" width="50%"/></center>
<pre>
<kc>//OUTPUT</kc>
BEGINS CPU=4 thread=main | nthreads=1
Counter INITIAL VALUE=0
INC | 10000 in thread=main | nthreads=1 full=true
INC | 20000 in thread=main | nthreads=1 full=true
INC | 30000 in thread=main | nthreads=1 full=true
INC | 40000 in thread=main | nthreads=1 full=true
INC | 50000 in thread=main | nthreads=1 full=true
INC | 60000 in thread=main | nthreads=1 full=true
INC | 70000 in thread=main | nthreads=1 full=true
INC | 80000 in thread=main | nthreads=1 full=true
INC | 90000 in thread=main | nthreads=1 full=true
Completed 100000 actions in 414 ms
Counter FINAL VALUE= = 100000
ENDS thread=main | nthreads=1
</pre>
<m></m> 
</td>
</tr>
</tbody>	
</table></center>
<!--
A simple actor can be written as a function, but an actor with a complex state  is better suited for a class.<br/>
-->
 
 
<br/><br/> 
</div>  
<div style="background-color:rgba(86, 56, 253, 0.9); width:100%;text-align:center;font-size:small;color:white">
By AN Unibo-DISI    
</div> 
</body>
</html>

<!--
class CounterMsg( 
	val cmd:String, val replyChannel:SendChannel<Int>?=null){
}

fun counterActor() : SendChannel<CounterMsg> = GlobalScope.actor<CounterMsg> {
    var localCounter = 0 // actor state
    for (msg in channel) { // iterate over messages
        when ( msg.cmd ) {
            "INC" -> localCounter++
            "DEC" -> localCounter--
            "GET" -> msg.replyChannel?.send(localCounter)
            else -> throw Exception( "unknown" )
        }    }
}

suspend fun useTheCounter(){
    val counter = counterActor()
    println("INC")
    counter.send( CounterMsg("INC") )

    val answerChannel = Channel<Int>()
    counter.send( CounterMsg("GET", answerChannel) )

    val answer = answerChannel.receive()
    println("useTheCounter COUNTER = $answer")
}

fun main() = runBlocking{
    println("BEGINS")
    useTheCounter()
    println("ENDS")
}

//OUTPUT
BEGINS with 4  cores
INC
useTheCounter COUNTER = 1
ENDS 
-->