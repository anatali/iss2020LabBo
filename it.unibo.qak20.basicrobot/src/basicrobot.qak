/* 
 * ================================================================================
 * basicrobot.qak
 * VERSION May 31, 2020
 * The basicrobot emits the event  obstacle : obstacle(ID)
 * The envsonarhandler  emits the event polar : polar( D,A )
 *  		(without giving this responsibility to the basicrobot)
 * 
 * You can command the robot by using 
 * 		resources\consolepython\basicrobotconsole.py
 * or 	resources\consolegui\consoleGuiCoap.kt (look at sysConnKb.kt)
 * 
 * External MQTT sites:
 * 	"mqtt.eclipse.org:  mosquitto.org mqtt.fluux.io  broker.hivemq.com
 * ================================================================================
 */ 
  
System -msglog basicrobot 
//mqttBroker "localhost" : 1883 eventTopic "unibo/polar"   

Dispatch cmd       	: cmd(MOVE)    
Dispatch end       	: end(ARG)  
 
Request step       : step( TIME )	
Reply   stepdone   : stepdone(V)  
Reply   stepfail   : stepfail(DURATION, CAUSE)
  
Event   obstacle   : obstacle( ARG ) 	//generated by distancefilter
Event  endall	   : endall( ARG )   

Event  polar     	: polar(DISTANCE,ARG)   		//emitted for the radar
Event  local_sonar	: sonar(DISTANCE,NAME)			//emitted by the virtual robot support
Event  sonar     	: sonar(DISTANCE,NAME)
 
Context ctxbasicrobot ip [host="localhost" port=8020]  

CodedQActor datacleaner    context ctxbasicrobot className "rx.dataCleaner"
CodedQActor distancefilter context ctxbasicrobot className "rx.distanceFilter"
 
QActor basicrobot context ctxbasicrobot{
[#
  var StepTime      = 0L
  var StartTime     = 0L    
  var Duration      = 0L    
#]  
 	State s0 initial { 	 
 		println("basicrobot | START")	
 		qrun unibo.robot.robotSupport.create(myself,"basicrobotConfig.json")	
// 		delay 1000  //give to the realsonar (if any) the time to start
 		println("basicrobot | attempts to activate the sonar pipe")	
 		[#  //For real robots
 			var robotsonar = context!!.hasActor("realsonar")  
 			if( robotsonar != null ){ 
 				println("basicrobot | WORKING WITH SONARS") 
 				//ACTIVATE THE DATA SOURCE realsonar
 				forward("sonarstart", "sonarstart(1)" ,"realsonar" ) 				
 				//SET THE PIPE  
 				robotsonar.
 				subscribeLocalActor("datacleaner").
 				subscribeLocalActor("distancefilter").
 				subscribeLocalActor("basicrobot")		//in order to perceive obstacle
 			}else{
 				println("basicrobot | WARNING: realsonar NOT FOUND")
 			}
 		#]
  		run unibo.robot.robotSupport.move( "l" )
		run unibo.robot.robotSupport.move( "r" )
 		updateResource [# "stopped" #]
 		discardMsg Off  //WE want receive any msg
 	}
	Goto work
	
	State work{ 
	} 
	Transition t1   whenMsg     cmd       -> execcmd
					whenRequest step      -> doStep
					whenEvent  obstacle   -> handleObstacle
					whenEvent sonar       -> handleSonar
				  	whenMsg     end       -> endwork			  
	
	State execcmd{
		printCurrentMessage
		onMsg( cmd : cmd(MOVE) ){
  			//activate the motors 
			run unibo.robot.robotSupport.move( payloadArg(0 ) )
			updateResource [# "movedone(${payloadArg(0)})" #]
		}
	 }
	 Goto work  
	 
	State handleObstacle{
		//printCurrentMessage
		println("basicrobot | handleObstacle")	
		run robotMbot.mbotSupport.move( "h" )
		//back to avoid obstacle again
		run robotMbot.mbotSupport.move( "s" )
		delay 400
		run robotMbot.mbotSupport.move( "h" )
		onMsg( obstacle  : obstacle( TARGET ) ){
			updateResource [# "obstacle" #]
 		}
	}
	Goto work 

	State handleSonar{
		printCurrentMessage
	}
	Goto work
		
   	State doStep{ 
 		//printCurrentMessage  
		onMsg( step : step( T ) ){  
			[#	StepTime = payloadArg(0).toLong() 	#]  
			updateResource [# "step(${StepTime})" #]
			//println("basicrobot | doStep StepTime =$StepTime ")
 			run unibo.robot.robotSupport.move( "w" )
 			memoCurrentTime StartTime  
		}  
	}  
	Transition t0 
		whenTimeVar StepTime      -> stepPerhapsDone	
		whenEvent  obstacle       -> stepFail		 
  	
 	State stepPerhapsDone{ 
 		run unibo.robot.robotSupport.move( "h" )  //stop the robot
		onMsg( local_sonar : sonar(D,T)){ 
			println("basicrobot | after a step emit polar(${payloadArg(0)}, 180) ")
			emit polar    : polar( $payloadArg(0), 180 )		//perceived via mqtt			
 		}
  	}
 	Transition t0 whenTimeVar StepTime    -> stepDone  //StepTime is the worst case
 				  whenEvent obstacle      -> stepFailDetected
	
	State stepDone{   
 		run unibo.robot.robotSupport.move( "h" )  //stop the robot
		//println("basicrobot | stepDone ")
		updateResource [# "stepDone($StepTime)" #]
   		replyTo step with stepdone : stepdone(ok)
  	}
	Goto work  
	
	State stepFailDetected{
		println("basicrobot | stepFailDetected near end of step ")
 		replyTo step with stepfail : stepfail($StepTime, obstacle)
    }
	Goto work 
	 
	State stepFail{  
		setDuration Duration from StartTime
 		updateResource [# "stepFail($Duration)" #]
		//println("basicrobot | stepFail after $Duration ")
		emit obstacle : obstacle(unknown)
		emit polar    : polar( 10, 90 )		 
 		replyTo step with stepfail : stepfail($Duration, obstacle)
    }
	Goto work 
	
	State endwork{ 
		onMsg( end : end( V ) ){ 
			println("basicrobot | endwork")
			updateResource [# "move(end)" #]	 		
			run utils.virtualRobotSupportQak.terminatevr( )
		}
 		emit endall : endall(normal) 
 		terminate 1
	}  
	   
}
/*
QActor envsonarhandler context ctxbasicrobot{
 	State s0 initial { 	 
 		println("envsonarhandler | START")	 		
	}	
	Transition t1   whenEvent local_sonar -> handleEnvSonar
	
	State handleEnvSonar{
		onMsg( local_sonar : sonar(D,T)){ 
			println("envsonarhandler | emit polar(${payloadArg(0)}, 180) ")
			emit polar    : polar( $payloadArg(0), 180 )		//perceived via mqtt
		}
	}
	Goto s0  
	
}
*/
/* 
 * 
//Just to test that the event is emiited ...
QActor perceiver context ctxbasicrobot{
 	State s0 initial { 	 
 		println("perceiver | START")	 		
	}	
	Transition t1   whenEvent polar-> handlePolar
 
  State handlePolar{
  	printCurrentMessage
  }
  Goto s0
}
* */